(function(e){function t(t){for(var a,r,n=t[0],c=t[1],d=t[2],p=0,u=[];p<n.length;p++)r=n[p],Object.prototype.hasOwnProperty.call(o,r)&&o[r]&&u.push(o[r][0]),o[r]=0;for(a in c)Object.prototype.hasOwnProperty.call(c,a)&&(e[a]=c[a]);l&&l(t);while(u.length)u.shift()();return i.push.apply(i,d||[]),s()}function s(){for(var e,t=0;t<i.length;t++){for(var s=i[t],a=!0,n=1;n<s.length;n++){var c=s[n];0!==o[c]&&(a=!1)}a&&(i.splice(t--,1),e=r(r.s=s[0]))}return e}var a={},o={app:0},i=[];function r(t){if(a[t])return a[t].exports;var s=a[t]={i:t,l:!1,exports:{}};return e[t].call(s.exports,s,s.exports,r),s.l=!0,s.exports}r.m=e,r.c=a,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(s,a,function(t){return e[t]}.bind(null,a));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="/";var n=window["webpackJsonp"]=window["webpackJsonp"]||[],c=n.push.bind(n);n.push=t,n=n.slice();for(var d=0;d<n.length;d++)t(n[d]);var l=c;i.push([0,"chunk-vendors"]),s()})({0:function(e,t,s){e.exports=s("56d7")},"56d7":function(e,t,s){"use strict";s.r(t);s("cadf"),s("551c"),s("f751"),s("097d");var a=s("2b0e"),o=function(){var e=this,t=e._self._c;return t("div",{attrs:{id:"app"}},[t("div",{staticClass:"content"},[t("JsonViewer")],1)])},i=[],r=function(){var e=this,t=e._self._c;return t("div",{staticClass:"center"},[t("div",{staticClass:"left"},[t("div",{staticClass:"json-tree left-center"},[t("div",{staticClass:"json-viewer"},[t("tree",{attrs:{data:e.json,options:e.treeOptions},on:{"node:selected":e.selectNode},scopedSlots:e._u([{key:"default",fn:function(s){var a=s.node;return t("span",{staticClass:"viewer-item",class:["viewer-type--"+a.data.type]},[a.hasChildren()?t("span",{staticClass:"viewer-item__key"},[t("span",{staticClass:"viewer-item__key"},[e._v("\n                "+e._s(a.text)+"\n                "),a.data.array?t("span",{staticClass:"viewer-item__array"},[e._v("[ ]")]):e._e()]),a.collapsed()?t("span",["array"==a.data.type?[e._v("[ "+e._s(a.children.length)+" ]")]:[e._v("{ "+e._s(a.children.length)+" }")]],2):e._e()]):t("span",{staticClass:"viewer-item__prop"},[t("span",{staticClass:"viewer-item__key"},[e._v("\n                "+e._s(a.text)+"\n                "),a.data.array?t("span",{staticClass:"viewer-item__array"},[e._v("[ ]")]):e._e()]),e._v("\n              :\n              "),t("span",{staticClass:"viewer-item__value_bold"},["apiVersion"==a.text?[e._v('"'+e._s(a.data.version)+'"')]:e._e(),"kind"==a.text?[e._v('"'+e._s(a.data.kind)+'"')]:e._e()],2),t("span",{staticClass:"viewer-item__value"},["kind"!=a.text&&"apiVersion"!=a.text?[e._v(e._s(a.data.objectKey))]:e._e()],2)])])}}])})],1)]),e._m(0),e._m(1)]),e._m(2)])},n=[function(){var e=this,t=e._self._c;return t("div",{staticClass:"footer-text"},[t("h3",[e._v("项目的发展离不开你的支持，请作者喝杯咖啡吧！")]),t("h4",{staticStyle:{color:"red"}},[e._v("留下邮箱还可以获得"),t("br"),e._v("本项目前端源码和完整的 k8s api 结构化数据")]),t("h5",[t("a",{staticStyle:{"text-decoration":"none"},attrs:{href:"mailto:abel533@gmail.com"}},[e._v("abel533@gmail.com")])])])},function(){var e=this,t=e._self._c;return t("div",{staticClass:"footer"},[t("img",{attrs:{src:"https://mybatis.io/img/wx_pay.png",width:"200"}}),t("img",{attrs:{src:"https://mybatis.io/img/ali_pay.png",width:"200"}})])},function(){var e=this,t=e._self._c;return t("div",{staticClass:"right"},[t("iframe",{attrs:{id:"api-html",src:"./html/",width:"100%",height:"100%",frameborder:"0"}})])}],c=(s("ac6a"),s("456d"),s("53ca")),d=(s("28a5"),s("6762"),s("2fdb"),s("ade3")),l=(s("7f7f"),s("25ea"));s("8e6e");function p(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,a)}return s}function u(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?p(Object(s),!0).forEach((function(t){Object(d["a"])(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):p(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function h(e){for(var t={text:"Kubernetes API Reference Docs - v1.28",children:[],data:{type:"array"},state:{expanded:!0}},s=["string","boolean","integer","object"],a=0;a<e.topLevel.length;a++){var o=e.topLevel[a];e.types[o]&&t.children.push(i(o,0))}function i(t,a){var o=e.types[t],r={text:o.name,data:u(u({},o),{},{type:"object"})};if(a>0&&(r.data.objectKey=o.name),o&&o.fields){r.children=[];for(var n=0;n<o.fields.length;n++){var c=o.fields[n];if(c.typeRefId&&c.typeRefId!=t&&e.types[c.typeRefId]&&s.indexOf(c.typeRefId)<0)if(a<20){var d=i(c.typeRefId,a+1);d.text=c.name,d.data.array=c.array,r.children.push(d)}else r.children.push({text:c.name+"Too Deep!!!",data:u(u({},c),{},{type:c.typeRefId,objectKey:c.typeRefId})});else r.children.push({text:c.name,data:u(u({},c),{},{version:o.version,kind:o.kind,type:c.typeRefId,objectKey:c.typeRefId})})}}return r}return t}var m=s("e14f");console.log("11111111111");var f={name:"JsonViewer",components:Object(d["a"])({},l["a"].name,l["a"]),data:function(){return{baseUrl:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/",json:h(m),treeOptions:{}}},methods:{selectNode:function(e){e.data.id&&this.appendIdToIframeSrc(e.data.id)},appendIdToIframeSrc:function(e){var t=document.querySelector("#api-html"),s=t.getAttribute("src");s.includes("#")?s=s.split("#")[0]+"#"+e:s+="#"+e,t.setAttribute("src",s)},isString:function(e){return"string"==typeof e},isNaN:function(e){return e!==e},isBoolean:function(e){return"boolean"==typeof e},isNumber:function(e){return"number"==typeof e},isArray:function(e){return Array.isArray(e)},isValue:function(e){return!this.isArray(e)&&!this.isPlainObject(e)},isPlainObject:function(e){function t(e){return null!=e&&"object"===Object(c["a"])(e)&&!1===Array.isArray(e)}return!!(t(e)&&e.constructor&&e.constructor.prototype)&&!0===e.constructor.prototype.hasOwnProperty("isPrototypeOf")},isIterable:function(e){return this.isArray(e)||this.isPlainObject(e)},map:function(e,t){return Object.keys(e).map((function(s){return t(e[s],s)}))},transformObject:function(e,t){var s={text:t};return this.isIterable(e)?(s.children=this.map(e,this.transformObject),s.data={type:this.isArray(e)?"array":this.isPlainObject(e)?"object":"unknown"}):s.data={objectKey:e||"".concat(e),type:this.getType(e)},s},getType:function(e){return this.isNaN(e)?"viewer-type--nan":this.isString(e)?"viewer-type--string":this.isNumber(e)?"viewer-type--integer":this.isBoolean(e)?"viewer-type--boolean":null===e?"viewer-type--null":void 0},parser:function(e){return[{text:"JSONObject",state:{expanded:!0},data:{type:"root"},children:this.map(e,this.transformObject)}]}}},y=f,v=(s("850f"),s("2877")),b=Object(v["a"])(y,r,n,!1,null,null,null),g=b.exports,I={name:"app",components:{JsonViewer:g}};(function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d509a6c67b04a5bb16e4a4bdbd512bae";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})();var R=I,w=Object(v["a"])(R,o,i,!1,null,null,null),S=w.exports;a["a"].config.productionTip=!1,new a["a"]({render:function(e){return e(S)}}).$mount("#app")},"850f":function(e,t,s){"use strict";s("b353")},b353:function(e,t,s){},e14f:function(e){e.exports=JSON.parse('{"topLevel":["container-v1-core","cronjob-v1-batch","daemonset-v1-apps","deployment-v1-apps","job-v1-batch","pod-v1-core","replicaset-v1-apps","replicationcontroller-v1-core","statefulset-v1-apps","endpoints-v1-core","service-v1-core","configmap-v1-core","secret-v1-core","persistentvolumeclaim-v1-core","volume-v1-core","controllerrevision-v1-apps","limitrange-v1-core","horizontalpodautoscaler-v2-autoscaling","podtemplate-v1-core","poddisruptionbudget-v1-policy","binding-v1-core","componentstatus-v1-core","namespace-v1-core","node-v1-core","persistentvolume-v1-core","resourcequota-v1-core","serviceaccount-v1-core","apigroup-v1-meta","apiresource-v1-meta","apiversions-v1-meta","awselasticblockstorevolumesource-v1-core","affinity-v1-core","apparmorprofile-v1-core","attachedvolume-v1-core","azurediskvolumesource-v1-core","azurefilepersistentvolumesource-v1-core","azurefilevolumesource-v1-core","csipersistentvolumesource-v1-core","csivolumesource-v1-core","capabilities-v1-core","cephfspersistentvolumesource-v1-core","cephfsvolumesource-v1-core","cinderpersistentvolumesource-v1-core","cindervolumesource-v1-core","clientipconfig-v1-core","clustertrustbundleprojection-v1-core","componentcondition-v1-core","condition-v1-meta","configmapenvsource-v1-core","configmapkeyselector-v1-core","configmapnodeconfigsource-v1-core","configmapprojection-v1-core","configmapvolumesource-v1-core","containerextendedresourcerequest-v1-core","containerimage-v1-core","containerport-v1-core","containerresizepolicy-v1-core","containerresourcemetricsource-v2-autoscaling","containerresourcemetricstatus-v2-autoscaling","containerrestartrule-v1-core","containerrestartruleonexitcodes-v1-core","containerstate-v1-core","containerstaterunning-v1-core","containerstateterminated-v1-core","containerstatewaiting-v1-core","containeruser-v1-core","crossversionobjectreference-v2-autoscaling","daemonendpoint-v1-core","daemonsetcondition-v1-apps","daemonsetupdatestrategy-v1-apps","deleteoptions-v1-meta","deploymentcondition-v1-apps","downwardapiprojection-v1-core","downwardapivolumefile-v1-core","downwardapivolumesource-v1-core","emptydirvolumesource-v1-core","endpointaddress-v1-core","endpointport-v1-core","endpointsubset-v1-core","envfromsource-v1-core","envvar-v1-core","envvarsource-v1-core","ephemeralcontainer-v1-core","ephemeralvolumesource-v1-core","eventsource-v1-core","eviction-v1-policy","execaction-v1-core","externalmetricsource-v2-autoscaling","externalmetricstatus-v2-autoscaling","fcvolumesource-v1-core","fieldselectorrequirement-v1-meta","filekeyselector-v1-core","flexpersistentvolumesource-v1-core","flexvolumesource-v1-core","flockervolumesource-v1-core","gcepersistentdiskvolumesource-v1-core","grpcaction-v1-core","gitrepovolumesource-v1-core","glusterfspersistentvolumesource-v1-core","glusterfsvolumesource-v1-core","groupversionfordiscovery-v1-meta","hpascalingpolicy-v2-autoscaling","hpascalingrules-v2-autoscaling","httpgetaction-v1-core","httpheader-v1-core","horizontalpodautoscalerbehavior-v2-autoscaling","horizontalpodautoscalercondition-v2-autoscaling","hostalias-v1-core","hostip-v1-core","hostpathvolumesource-v1-core","iscsipersistentvolumesource-v1-core","iscsivolumesource-v1-core","imagevolumesource-v1-core","jobcondition-v1-batch","jobtemplatespec-v1-batch","keytopath-v1-core","labelselector-v1-meta","labelselectorrequirement-v1-meta","lifecycle-v1-core","lifecyclehandler-v1-core","limitrangeitem-v1-core","linuxcontaineruser-v1-core","listmeta-v1-meta","loadbalanceringress-v1-core","loadbalancerstatus-v1-core","localobjectreference-v1-core","localvolumesource-v1-core","managedfieldsentry-v1-meta","metricidentifier-v2-autoscaling","metricspec-v2-autoscaling","metricstatus-v2-autoscaling","metrictarget-v2-autoscaling","metricvaluestatus-v2-autoscaling","microtime-v1-meta","modifyvolumestatus-v1-core","nfsvolumesource-v1-core","namespacecondition-v1-core","nodeaddress-v1-core","nodeaffinity-v1-core","nodecondition-v1-core","nodeconfigsource-v1-core","nodeconfigstatus-v1-core","nodedaemonendpoints-v1-core","nodefeatures-v1-core","noderuntimehandler-v1-core","noderuntimehandlerfeatures-v1-core","nodeselector-v1-core","nodeselectorrequirement-v1-core","nodeselectorterm-v1-core","nodeswapstatus-v1-core","nodesysteminfo-v1-core","objectfieldselector-v1-core","objectmeta-v1-meta","objectmetricsource-v2-autoscaling","objectmetricstatus-v2-autoscaling","objectreference-v1-core","ownerreference-v1-meta","patch-v1-meta","persistentvolumeclaimcondition-v1-core","persistentvolumeclaimtemplate-v1-core","persistentvolumeclaimvolumesource-v1-core","photonpersistentdiskvolumesource-v1-core","podaffinity-v1-core","podaffinityterm-v1-core","podantiaffinity-v1-core","podcertificateprojection-v1-core","podcondition-v1-core","poddnsconfig-v1-core","poddnsconfigoption-v1-core","podextendedresourceclaimstatus-v1-core","podfailurepolicy-v1-batch","podfailurepolicyonexitcodesrequirement-v1-batch","podfailurepolicyonpodconditionspattern-v1-batch","podfailurepolicyrule-v1-batch","podip-v1-core","podos-v1-core","podreadinessgate-v1-core","podresourceclaim-v1-core","podschedulinggate-v1-core","podsecuritycontext-v1-core","podsmetricsource-v2-autoscaling","podsmetricstatus-v2-autoscaling","portstatus-v1-core","portworxvolumesource-v1-core","preconditions-v1-meta","preferredschedulingterm-v1-core","probe-v1-core","projectedvolumesource-v1-core","quobytevolumesource-v1-core","rbdpersistentvolumesource-v1-core","rbdvolumesource-v1-core","replicasetcondition-v1-apps","replicationcontrollercondition-v1-core","resourceclaim-v1-core","resourcefieldselector-v1-core","resourcehealth-v1-core","resourcemetricsource-v2-autoscaling","resourcemetricstatus-v2-autoscaling","resourcerequirements-v1-core","resourcestatus-v1-core","rollingupdatestatefulsetstrategy-v1-apps","selinuxoptions-v1-core","scale-v1-autoscaling","scaleiopersistentvolumesource-v1-core","scaleiovolumesource-v1-core","scopeselector-v1-core","scopedresourceselectorrequirement-v1-core","seccompprofile-v1-core","secretenvsource-v1-core","secretkeyselector-v1-core","secretprojection-v1-core","secretreference-v1-core","secretvolumesource-v1-core","securitycontext-v1-core","serveraddressbyclientcidr-v1-meta","serviceaccounttokenprojection-v1-core","serviceport-v1-core","sessionaffinityconfig-v1-core","sleepaction-v1-core","statefulsetcondition-v1-apps","statefulsetordinals-v1-apps","statefulsetpersistentvolumeclaimretentionpolicy-v1-apps","statefulsetupdatestrategy-v1-apps","status-v1-meta","statuscause-v1-meta","statusdetails-v1-meta","storageospersistentvolumesource-v1-core","storageosvolumesource-v1-core","successpolicy-v1-batch","successpolicyrule-v1-batch","sysctl-v1-core","tcpsocketaction-v1-core","taint-v1-core","time-v1-meta","toleration-v1-core","topologyselectorlabelrequirement-v1-core","topologyselectorterm-v1-core","topologyspreadconstraint-v1-core","typedlocalobjectreference-v1-core","typedobjectreference-v1-core","uncountedterminatedpods-v1-batch","volumedevice-v1-core","volumemount-v1-core","volumenodeaffinity-v1-core","volumeprojection-v1-core","volumeresourcerequirements-v1-core","vspherevirtualdiskvolumesource-v1-core","watchevent-v1-meta","weightedpodaffinityterm-v1-core","windowssecuritycontextoptions-v1-core","crossversionobjectreference-v1-autoscaling","event-v1-core","eventseries-v1-core","horizontalpodautoscaler-v1-autoscaling"],"types":{"null":{"name":"object","primitive":true},"container-v1-core":{"id":"container-v1-core","name":"Container v1 core","primitive":false,"description":"Container v1 core","group":"core","version":"v1","kind":"Container","warning":{"text":"Warning: Containers are only ever created within the context of a Pod. This is usually done using a Controller. See Controllers: Deployment, Job, or StatefulSet","html":"<i class=\\"fa fa-warning\\"></i> <b>Warning:</b>\\nContainers are only ever created within the context of a <a href=\\"#pod-v1-core\\">Pod</a>. This is usually done using a Controller. See Controllers: <a href=\\"#deployment-v1-apps\\">Deployment</a>, <a href=\\"#job-v1-batch\\">Job</a>, or <a href=\\"#statefulset-v1-apps\\">StatefulSet</a>"},"fields":[{"name":"args","description":"Arguments to the entrypoint. The container image\'s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\'s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \\"$$(VAR_NAME)\\" will produce the string literal \\"$(VAR_NAME)\\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell","typeRefId":"string","array":true},{"name":"command","description":"Entrypoint array. Not executed within a shell. The container image\'s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\'s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \\"$$(VAR_NAME)\\" will produce the string literal \\"$(VAR_NAME)\\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell","typeRefId":"string","array":true},{"name":"env","description":"List of environment variables to set in the container. Cannot be updated.","typeRefId":"envvar-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"envFrom","description":"List of sources to populate environment variables in the container. The keys defined within a source may consist of any printable ASCII characters except \'=\'. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.","typeRefId":"envfromsource-v1-core","array":true},{"name":"image","description":"Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.","typeRefId":"string","array":false},{"name":"imagePullPolicy","description":"Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images Possible enum values: - `\\"Always\\"` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails. - `\\"IfNotPresent\\"` means that kubelet pulls if the image isn\'t present on disk. Container will fail if the image isn\'t present and the pull fails. - `\\"Never\\"` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn\'t present","typeRefId":"string","array":false},{"name":"lifecycle","description":"Actions that the management system should take in response to container lifecycle events. Cannot be updated.","typeRefId":"lifecycle-v1-core","array":false},{"name":"livenessProbe","description":"Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes","typeRefId":"probe-v1-core","array":false},{"name":"name","description":"Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.","typeRefId":"string","array":false},{"name":"ports","description":"List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \\"0.0.0.0\\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.","typeRefId":"containerport-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"containerPort"}},{"name":"readinessProbe","description":"Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes","typeRefId":"probe-v1-core","array":false},{"name":"resizePolicy","description":"Resources resize policy for the container.","typeRefId":"containerresizepolicy-v1-core","array":true},{"name":"resources","description":"Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","typeRefId":"resourcerequirements-v1-core","array":false},{"name":"restartPolicy","description":"RestartPolicy defines the restart behavior of individual containers in a pod. This overrides the pod-level restart policy. When this field is not specified, the restart behavior is defined by the Pod\'s restart policy and the container type. Additionally, setting the RestartPolicy as \\"Always\\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \\"Always\\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \\"sidecar\\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.","typeRefId":"string","array":false},{"name":"restartPolicyRules","description":"Represents a list of rules to be checked to determine if the container should be restarted on exit. The rules are evaluated in order. Once a rule matches a container exit condition, the remaining rules are ignored. If no rule matches the container exit condition, the Container-level restart policy determines the whether the container is restarted or not. Constraints on the rules: - At most 20 rules are allowed. - Rules can have the same action. - Identical rules are not forbidden in validations. When rules are specified, container MUST set RestartPolicy explicitly even it if matches the Pod\'s RestartPolicy.","typeRefId":"containerrestartrule-v1-core","array":true},{"name":"securityContext","description":"SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/","typeRefId":"securitycontext-v1-core","array":false},{"name":"startupProbe","description":"StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod\'s lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes","typeRefId":"probe-v1-core","array":false},{"name":"stdin","description":"Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.","typeRefId":"boolean","array":false},{"name":"stdinOnce","description":"Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false","typeRefId":"boolean","array":false},{"name":"terminationMessagePath","description":"Optional: Path at which the file to which the container\'s termination message will be written is mounted into the container\'s filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.","typeRefId":"string","array":false},{"name":"terminationMessagePolicy","description":"Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. Possible enum values: - `\\"FallbackToLogsOnError\\"` will read the most recent contents of the container logs for the container status message when the container exits with an error and the terminationMessagePath has no contents. - `\\"File\\"` is the default behavior and will set the container status message to the contents of the container\'s terminationMessagePath when the container exits.","typeRefId":"string","array":false},{"name":"tty","description":"Whether this container should allocate a TTY for itself, also requires \'stdin\' to be true. Default is false.","typeRefId":"boolean","array":false},{"name":"volumeDevices","description":"volumeDevices is the list of block devices to be used by the container.","typeRefId":"volumedevice-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"devicePath"}},{"name":"volumeMounts","description":"Pod volumes to mount into the container\'s filesystem. Cannot be updated.","typeRefId":"volumemount-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"mountPath"}},{"name":"workingDir","description":"Container\'s working directory. If not specified, the container runtime\'s default will be used, which might be configured in the container image. Cannot be updated.","typeRefId":"string","array":false}],"appears":[{"typeRefId":"podspec-v1-core","text":"PodSpec [core/v1]"}]},"cronjob-v1-batch":{"id":"cronjob-v1-batch","name":"CronJob v1 batch","primitive":false,"description":"CronJob v1 batch","group":"batch","version":"v1","kind":"CronJob","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Specification of the desired behavior of a cron job, including the schedule. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"cronjobspec-v1-batch","array":false},{"name":"status","description":"Current status of a cron job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"cronjobstatus-v1-batch","array":false}],"appears":[{"typeRefId":"cronjoblist-v1-batch","text":"CronJobList [batch/v1]"}]},"daemonset-v1-apps":{"id":"daemonset-v1-apps","name":"DaemonSet v1 apps","primitive":false,"description":"DaemonSet v1 apps","group":"apps","version":"v1","kind":"DaemonSet","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"The desired behavior of this daemon set. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"daemonsetspec-v1-apps","array":false},{"name":"status","description":"The current status of this daemon set. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"daemonsetstatus-v1-apps","array":false}],"appears":[{"typeRefId":"daemonsetlist-v1-apps","text":"DaemonSetList [apps/v1]"}]},"deployment-v1-apps":{"id":"deployment-v1-apps","name":"Deployment v1 apps","primitive":false,"description":"Deployment v1 apps","group":"apps","version":"v1","kind":"Deployment","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Specification of the desired behavior of the Deployment.","typeRefId":"deploymentspec-v1-apps","array":false},{"name":"status","description":"Most recently observed status of the Deployment.","typeRefId":"deploymentstatus-v1-apps","array":false}],"appears":[{"typeRefId":"deploymentlist-v1-apps","text":"DeploymentList [apps/v1]"}]},"job-v1-batch":{"id":"job-v1-batch","name":"Job v1 batch","primitive":false,"description":"Job v1 batch","group":"batch","version":"v1","kind":"Job","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Specification of the desired behavior of a job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"jobspec-v1-batch","array":false},{"name":"status","description":"Current status of a job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"jobstatus-v1-batch","array":false}],"appears":[{"typeRefId":"joblist-v1-batch","text":"JobList [batch/v1]"}]},"pod-v1-core":{"id":"pod-v1-core","name":"Pod v1 core","primitive":false,"description":"Pod v1 core","group":"core","version":"v1","kind":"Pod","warning":{"text":"Warning: It is recommended that users create Pods only through a Controller, and not directly. See Controllers: Deployment, Job, or StatefulSet.","html":"<i class=\\"fa fa-warning\\"></i> <b>Warning:</b>\\nIt is recommended that users create Pods only through a Controller, and not directly. See Controllers: <a href=\\"#deployment-v1-apps\\">Deployment</a>, <a href=\\"#job-v1-batch\\">Job</a>, or <a href=\\"#statefulset-v1-apps\\">StatefulSet</a>."},"fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"podspec-v1-core","array":false},{"name":"status","description":"Most recently observed status of the pod. This data may not be up to date. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"podstatus-v1-core","array":false}],"appears":[{"typeRefId":"podlist-v1-core","text":"PodList [core/v1]"}]},"replicaset-v1-apps":{"id":"replicaset-v1-apps","name":"ReplicaSet v1 apps","primitive":false,"description":"ReplicaSet v1 apps","group":"apps","version":"v1","kind":"ReplicaSet","warning":{"text":"Warning: In many cases it is recommended to create a Deployment instead of ReplicaSet.","html":"<i class=\\"fa fa-warning\\"></i> <b>Warning:</b>\\nIn many cases it is recommended to create a <a href=\\"#deployment-v1-apps\\">Deployment</a> instead of ReplicaSet."},"fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s) that the ReplicaSet manages. Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the specification of the desired behavior of the ReplicaSet. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"replicasetspec-v1-apps","array":false},{"name":"status","description":"Status is the most recently observed status of the ReplicaSet. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"replicasetstatus-v1-apps","array":false}],"appears":[{"typeRefId":"replicasetlist-v1-apps","text":"ReplicaSetList [apps/v1]"}]},"replicationcontroller-v1-core":{"id":"replicationcontroller-v1-core","name":"ReplicationController v1 core","primitive":false,"description":"ReplicationController v1 core","group":"core","version":"v1","kind":"ReplicationController","warning":{"text":"Warning: In many cases it is recommended to create a Deployment instead of a ReplicationController.","html":"<i class=\\"fa fa-warning\\"></i> <b>Warning:</b>\\nIn many cases it is recommended to create a <a href=\\"#deployment-v1-apps\\">Deployment</a> instead of a ReplicationController."},"fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"If the Labels of a ReplicationController are empty, they are defaulted to be the same as the Pod(s) that the replication controller manages. Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the specification of the desired behavior of the replication controller. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"replicationcontrollerspec-v1-core","array":false},{"name":"status","description":"Status is the most recently observed status of the replication controller. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"replicationcontrollerstatus-v1-core","array":false}],"appears":[{"typeRefId":"replicationcontrollerlist-v1-core","text":"ReplicationControllerList [core/v1]"}]},"statefulset-v1-apps":{"id":"statefulset-v1-apps","name":"StatefulSet v1 apps","primitive":false,"description":"StatefulSet v1 apps","group":"apps","version":"v1","kind":"StatefulSet","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the desired identities of pods in this set.","typeRefId":"statefulsetspec-v1-apps","array":false},{"name":"status","description":"Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.","typeRefId":"statefulsetstatus-v1-apps","array":false}],"appears":[{"typeRefId":"statefulsetlist-v1-apps","text":"StatefulSetList [apps/v1]"}]},"endpoints-v1-core":{"id":"endpoints-v1-core","name":"Endpoints v1 core","primitive":false,"description":"Endpoints v1 core","group":"core","version":"v1","kind":"Endpoints","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"subsets","description":"The set of all endpoints is the union of all subsets. Addresses are placed into subsets according to the IPs they share. A single address with multiple ports, some of which are ready and some of which are not (because they come from different containers) will result in the address being displayed in different subsets for the different ports. No address will appear in both Addresses and NotReadyAddresses in the same subset. Sets of addresses and ports that comprise a service.","typeRefId":"endpointsubset-v1-core","array":true}],"appears":[{"typeRefId":"endpointslist-v1-core","text":"EndpointsList [core/v1]"}]},"service-v1-core":{"id":"service-v1-core","name":"Service v1 core","primitive":false,"description":"Service v1 core","group":"core","version":"v1","kind":"Service","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"servicespec-v1-core","array":false},{"name":"status","description":"Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"servicestatus-v1-core","array":false}],"appears":[{"typeRefId":"servicelist-v1-core","text":"ServiceList [core/v1]"}]},"configmap-v1-core":{"id":"configmap-v1-core","name":"ConfigMap v1 core","primitive":false,"description":"ConfigMap v1 core","group":"core","version":"v1","kind":"ConfigMap","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"binaryData","description":"BinaryData contains the binary data. Each key must consist of alphanumeric characters, \'-\', \'_\' or \'.\'. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet.","typeRefId":"object","array":false},{"name":"data","description":"Data contains the configuration data. Each key must consist of alphanumeric characters, \'-\', \'_\' or \'.\'. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process.","typeRefId":"object","array":false},{"name":"immutable","description":"Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.","typeRefId":"boolean","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false}],"appears":[{"typeRefId":"configmaplist-v1-core","text":"ConfigMapList [core/v1]"}]},"secret-v1-core":{"id":"secret-v1-core","name":"Secret v1 core","primitive":false,"description":"Secret v1 core","group":"core","version":"v1","kind":"Secret","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"data","description":"Data contains the secret data. Each key must consist of alphanumeric characters, \'-\', \'_\' or \'.\'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4","typeRefId":"object","array":false},{"name":"immutable","description":"Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.","typeRefId":"boolean","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"stringData","description":"stringData allows specifying non-binary secret data in string form. It is provided as a write-only input field for convenience. All keys and values are merged into the data field on write, overwriting any existing values. The stringData field is never output when reading from the API.","typeRefId":"object","array":false},{"name":"type","description":"Used to facilitate programmatic handling of secret data. More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types","typeRefId":"string","array":false}],"appears":[{"typeRefId":"secretlist-v1-core","text":"SecretList [core/v1]"}]},"persistentvolumeclaim-v1-core":{"id":"persistentvolumeclaim-v1-core","name":"PersistentVolumeClaim v1 core","primitive":false,"description":"PersistentVolumeClaim v1 core","group":"core","version":"v1","kind":"PersistentVolumeClaim","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims","typeRefId":"persistentvolumeclaimspec-v1-core","array":false},{"name":"status","description":"status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims","typeRefId":"persistentvolumeclaimstatus-v1-core","array":false}],"appears":[{"typeRefId":"persistentvolumeclaimlist-v1-core","text":"PersistentVolumeClaimList [core/v1]"},{"typeRefId":"statefulsetspec-v1-apps","text":"StatefulSetSpec [apps/v1]"}]},"volume-v1-core":{"id":"volume-v1-core","name":"Volume v1 core","primitive":false,"description":"Volume v1 core","group":"core","version":"v1","kind":"Volume","fields":[{"name":"awsElasticBlockStore","description":"awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet\'s host machine and then exposed to the pod. Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","typeRefId":"awselasticblockstorevolumesource-v1-core","array":false},{"name":"azureDisk","description":"azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type are redirected to the disk.csi.azure.com CSI driver.","typeRefId":"azurediskvolumesource-v1-core","array":false},{"name":"azureFile","description":"azureFile represents an Azure File Service mount on the host and bind mount to the pod. Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type are redirected to the file.csi.azure.com CSI driver.","typeRefId":"azurefilevolumesource-v1-core","array":false},{"name":"cephfs","description":"cephFS represents a Ceph FS mount on the host that shares a pod\'s lifetime. Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.","typeRefId":"cephfsvolumesource-v1-core","array":false},{"name":"cinder","description":"cinder represents a cinder volume attached and mounted on kubelets host machine. Deprecated: Cinder is deprecated. All operations for the in-tree cinder type are redirected to the cinder.csi.openstack.org CSI driver. More info: https://examples.k8s.io/mysql-cinder-pd/README.md","typeRefId":"cindervolumesource-v1-core","array":false},{"name":"configMap","description":"configMap represents a configMap that should populate this volume","typeRefId":"configmapvolumesource-v1-core","array":false},{"name":"csi","description":"csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.","typeRefId":"csivolumesource-v1-core","array":false},{"name":"downwardAPI","description":"downwardAPI represents downward API about the pod that should populate this volume","typeRefId":"downwardapivolumesource-v1-core","array":false},{"name":"emptyDir","description":"emptyDir represents a temporary directory that shares a pod\'s lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir","typeRefId":"emptydirvolumesource-v1-core","array":false},{"name":"ephemeral","description":"ephemeral represents a volume that is handled by a cluster storage driver. The volume\'s lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed. Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim). Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod. Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information. A pod can use both types of ephemeral volumes and persistent volumes at the same time.","typeRefId":"ephemeralvolumesource-v1-core","array":false},{"name":"fc","description":"fc represents a Fibre Channel resource that is attached to a kubelet\'s host machine and then exposed to the pod.","typeRefId":"fcvolumesource-v1-core","array":false},{"name":"flexVolume","description":"flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.","typeRefId":"flexvolumesource-v1-core","array":false},{"name":"flocker","description":"flocker represents a Flocker volume attached to a kubelet\'s host machine. This depends on the Flocker control service being running. Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.","typeRefId":"flockervolumesource-v1-core","array":false},{"name":"gcePersistentDisk","description":"gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet\'s host machine and then exposed to the pod. Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","typeRefId":"gcepersistentdiskvolumesource-v1-core","array":false},{"name":"gitRepo","description":"gitRepo represents a git repository at a particular revision. Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod\'s container.","typeRefId":"gitrepovolumesource-v1-core","array":false},{"name":"glusterfs","description":"glusterfs represents a Glusterfs mount on the host that shares a pod\'s lifetime. Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.","typeRefId":"glusterfsvolumesource-v1-core","array":false},{"name":"hostPath","description":"hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath","typeRefId":"hostpathvolumesource-v1-core","array":false},{"name":"image","description":"image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet\'s host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided: - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn\'t present. - IfNotPresent: the kubelet pulls if the reference isn\'t already present on disk. Container creation will fail if the reference isn\'t present and the pull fails. The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33. The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.","typeRefId":"imagevolumesource-v1-core","array":false},{"name":"iscsi","description":"iscsi represents an ISCSI Disk resource that is attached to a kubelet\'s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi","typeRefId":"iscsivolumesource-v1-core","array":false},{"name":"name","description":"name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","typeRefId":"string","array":false},{"name":"nfs","description":"nfs represents an NFS mount on the host that shares a pod\'s lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs","typeRefId":"nfsvolumesource-v1-core","array":false},{"name":"persistentVolumeClaim","description":"persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims","typeRefId":"persistentvolumeclaimvolumesource-v1-core","array":false},{"name":"photonPersistentDisk","description":"photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine. Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.","typeRefId":"photonpersistentdiskvolumesource-v1-core","array":false},{"name":"portworxVolume","description":"portworxVolume represents a portworx volume attached and mounted on kubelets host machine. Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate is on.","typeRefId":"portworxvolumesource-v1-core","array":false},{"name":"projected","description":"projected items for all in one resources secrets, configmaps, and downward API","typeRefId":"projectedvolumesource-v1-core","array":false},{"name":"quobyte","description":"quobyte represents a Quobyte mount on the host that shares a pod\'s lifetime. Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.","typeRefId":"quobytevolumesource-v1-core","array":false},{"name":"rbd","description":"rbd represents a Rados Block Device mount on the host that shares a pod\'s lifetime. Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.","typeRefId":"rbdvolumesource-v1-core","array":false},{"name":"scaleIO","description":"scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes. Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.","typeRefId":"scaleiovolumesource-v1-core","array":false},{"name":"secret","description":"secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret","typeRefId":"secretvolumesource-v1-core","array":false},{"name":"storageos","description":"storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes. Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.","typeRefId":"storageosvolumesource-v1-core","array":false},{"name":"vsphereVolume","description":"vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine. Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type are redirected to the csi.vsphere.vmware.com CSI driver.","typeRefId":"vspherevirtualdiskvolumesource-v1-core","array":false}],"appears":[{"typeRefId":"podspec-v1-core","text":"PodSpec [core/v1]"}]},"controllerrevision-v1-apps":{"id":"controllerrevision-v1-apps","name":"ControllerRevision v1 apps","primitive":false,"description":"ControllerRevision v1 apps","group":"apps","version":"v1","kind":"ControllerRevision","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"data","description":"Data is the serialized representation of the state.","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"revision","description":"Revision indicates the revision of the state represented by Data.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"controllerrevisionlist-v1-apps","text":"ControllerRevisionList [apps/v1]"}]},"limitrange-v1-core":{"id":"limitrange-v1-core","name":"LimitRange v1 core","primitive":false,"description":"LimitRange v1 core","group":"core","version":"v1","kind":"LimitRange","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the limits enforced. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"limitrangespec-v1-core","array":false}],"appears":[{"typeRefId":"limitrangelist-v1-core","text":"LimitRangeList [core/v1]"}]},"horizontalpodautoscaler-v2-autoscaling":{"id":"horizontalpodautoscaler-v2-autoscaling","name":"HorizontalPodAutoscaler v2 autoscaling","primitive":false,"description":"HorizontalPodAutoscaler v2 autoscaling","group":"autoscaling","version":"v2","kind":"HorizontalPodAutoscaler","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"metadata is the standard object metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"spec is the specification for the behaviour of the autoscaler. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.","typeRefId":"horizontalpodautoscalerspec-v2-autoscaling","array":false},{"name":"status","description":"status is the current information about the autoscaler.","typeRefId":"horizontalpodautoscalerstatus-v2-autoscaling","array":false}],"appears":[{"typeRefId":"horizontalpodautoscalerlist-v2-autoscaling","text":"HorizontalPodAutoscalerList [autoscaling/v2]"}]},"podtemplate-v1-core":{"id":"podtemplate-v1-core","name":"PodTemplate v1 core","primitive":false,"description":"PodTemplate v1 core","group":"core","version":"v1","kind":"PodTemplate","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"template","description":"Template defines the pods that will be created from this pod template. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"podtemplatespec-v1-core","array":false}],"appears":[{"typeRefId":"podtemplatelist-v1-core","text":"PodTemplateList [core/v1]"}]},"poddisruptionbudget-v1-policy":{"id":"poddisruptionbudget-v1-policy","name":"PodDisruptionBudget v1 policy","primitive":false,"description":"PodDisruptionBudget v1 policy","group":"policy","version":"v1","kind":"PodDisruptionBudget","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Specification of the desired behavior of the PodDisruptionBudget.","typeRefId":"poddisruptionbudgetspec-v1-policy","array":false},{"name":"status","description":"Most recently observed status of the PodDisruptionBudget.","typeRefId":"poddisruptionbudgetstatus-v1-policy","array":false}],"appears":[{"typeRefId":"poddisruptionbudgetlist-v1-policy","text":"PodDisruptionBudgetList [policy/v1]"}]},"binding-v1-core":{"id":"binding-v1-core","name":"Binding v1 core","primitive":false,"description":"Binding v1 core","group":"core","version":"v1","kind":"Binding","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"target","description":"The target object that you want to bind to the standard object.","typeRefId":"objectreference-v1-core","array":false}]},"componentstatus-v1-core":{"id":"componentstatus-v1-core","name":"ComponentStatus v1 core","primitive":false,"description":"ComponentStatus v1 core","group":"core","version":"v1","kind":"ComponentStatus","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"conditions","description":"List of component conditions observed","typeRefId":"componentcondition-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false}],"appears":[{"typeRefId":"componentstatuslist-v1-core","text":"ComponentStatusList [core/v1]"}]},"namespace-v1-core":{"id":"namespace-v1-core","name":"Namespace v1 core","primitive":false,"description":"Namespace v1 core","group":"core","version":"v1","kind":"Namespace","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the behavior of the Namespace. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"namespacespec-v1-core","array":false},{"name":"status","description":"Status describes the current status of a Namespace. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"namespacestatus-v1-core","array":false}],"appears":[{"typeRefId":"namespacelist-v1-core","text":"NamespaceList [core/v1]"}]},"node-v1-core":{"id":"node-v1-core","name":"Node v1 core","primitive":false,"description":"Node v1 core","group":"core","version":"v1","kind":"Node","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the behavior of a node. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"nodespec-v1-core","array":false},{"name":"status","description":"Most recently observed status of the node. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"nodestatus-v1-core","array":false}],"appears":[{"typeRefId":"nodelist-v1-core","text":"NodeList [core/v1]"}]},"persistentvolume-v1-core":{"id":"persistentvolume-v1-core","name":"PersistentVolume v1 core","primitive":false,"description":"PersistentVolume v1 core","group":"core","version":"v1","kind":"PersistentVolume","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"spec defines a specification of a persistent volume owned by the cluster. Provisioned by an administrator. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes","typeRefId":"persistentvolumespec-v1-core","array":false},{"name":"status","description":"status represents the current information/status for the persistent volume. Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes","typeRefId":"persistentvolumestatus-v1-core","array":false}],"appears":[{"typeRefId":"persistentvolumelist-v1-core","text":"PersistentVolumeList [core/v1]"}]},"resourcequota-v1-core":{"id":"resourcequota-v1-core","name":"ResourceQuota v1 core","primitive":false,"description":"ResourceQuota v1 core","group":"core","version":"v1","kind":"ResourceQuota","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Spec defines the desired quota. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"resourcequotaspec-v1-core","array":false},{"name":"status","description":"Status defines the actual enforced quota and its current usage. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"resourcequotastatus-v1-core","array":false}],"appears":[{"typeRefId":"resourcequotalist-v1-core","text":"ResourceQuotaList [core/v1]"}]},"serviceaccount-v1-core":{"id":"serviceaccount-v1-core","name":"ServiceAccount v1 core","primitive":false,"description":"ServiceAccount v1 core","group":"core","version":"v1","kind":"ServiceAccount","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"automountServiceAccountToken","description":"AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level.","typeRefId":"boolean","array":false},{"name":"imagePullSecrets","description":"ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod","typeRefId":"localobjectreference-v1-core","array":true},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"secrets","description":"Secrets is a list of the secrets in the same namespace that pods running using this ServiceAccount are allowed to use. Pods are only limited to this list if this service account has a \\"kubernetes.io/enforce-mountable-secrets\\" annotation set to \\"true\\". The \\"kubernetes.io/enforce-mountable-secrets\\" annotation is deprecated since v1.32. Prefer separate namespaces to isolate access to mounted secrets. This field should not be used to find auto-generated service account token secrets for use outside of pods. Instead, tokens can be requested directly using the TokenRequest API, or service account token secrets can be manually created. More info: https://kubernetes.io/docs/concepts/configuration/secret","typeRefId":"objectreference-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}}],"appears":[{"typeRefId":"serviceaccountlist-v1-core","text":"ServiceAccountList [core/v1]"}]},"crossversionobjectreference-v1-autoscaling":{"id":"crossversionobjectreference-v1-autoscaling","name":"CrossVersionObjectReference v1 autoscaling","primitive":false,"description":"CrossVersionObjectReference v1 autoscaling","group":"autoscaling","version":"v1","kind":"CrossVersionObjectReference","fields":[{"name":"apiVersion","description":"apiVersion is the API version of the referent","typeRefId":"string","array":false},{"name":"kind","description":"kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"name","description":"name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names","typeRefId":"string","array":false}],"appears":[{"typeRefId":"horizontalpodautoscalerspec-v1-autoscaling","text":"HorizontalPodAutoscalerSpec [autoscaling/v1]"}]},"event-v1-core":{"id":"event-v1-core","name":"Event v1 core","primitive":false,"description":"Event v1 core","group":"core","version":"v1","kind":"Event","fields":[{"name":"action","description":"What action was taken/failed regarding to the Regarding object.","typeRefId":"string","array":false},{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"count","description":"The number of times this event has occurred.","typeRefId":"integer","array":false},{"name":"eventTime","description":"Time when this Event was first observed.","typeRefId":"microtime-v1-meta","array":false},{"name":"firstTimestamp","description":"The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)","typeRefId":"time-v1-meta","array":false},{"name":"involvedObject","description":"The object that this event is about.","typeRefId":"objectreference-v1-core","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"lastTimestamp","description":"The time at which the most recent occurrence of this event was recorded.","typeRefId":"time-v1-meta","array":false},{"name":"message","description":"A human-readable description of the status of this operation.","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"reason","description":"This should be a short, machine understandable string that gives the reason for the transition into the object\'s current status.","typeRefId":"string","array":false},{"name":"related","description":"Optional secondary object for more complex actions.","typeRefId":"objectreference-v1-core","array":false},{"name":"reportingComponent","description":"Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.","typeRefId":"string","array":false},{"name":"reportingInstance","description":"ID of the controller instance, e.g. `kubelet-xyzf`.","typeRefId":"string","array":false},{"name":"series","description":"Data about the Event series this event represents or nil if it\'s a singleton Event.","typeRefId":"eventseries-v1-core","array":false},{"name":"source","description":"The component reporting this event. Should be a short machine understandable string.","typeRefId":"eventsource-v1-core","array":false},{"name":"type","description":"Type of this event (Normal, Warning), new types could be added in the future","typeRefId":"string","array":false}],"appears":[{"typeRefId":"eventlist-v1-core","text":"EventList [core/v1]"}]},"eventseries-v1-core":{"id":"eventseries-v1-core","name":"EventSeries v1 core","primitive":false,"description":"EventSeries v1 core","group":"core","version":"v1","kind":"EventSeries","fields":[{"name":"count","description":"Number of occurrences in this series up to the last heartbeat time","typeRefId":"integer","array":false},{"name":"lastObservedTime","description":"Time of the last occurrence observed","typeRefId":"microtime-v1-meta","array":false}],"appears":[{"typeRefId":"event-v1-core","text":"Event [core/v1]"}]},"horizontalpodautoscaler-v1-autoscaling":{"id":"horizontalpodautoscaler-v1-autoscaling","name":"HorizontalPodAutoscaler v1 autoscaling","primitive":false,"description":"HorizontalPodAutoscaler v1 autoscaling","group":"autoscaling","version":"v1","kind":"HorizontalPodAutoscaler","fields":[{"name":"apiVersion","description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","typeRefId":"string","array":false},{"name":"kind","description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","typeRefId":"string","array":false},{"name":"metadata","description":"Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"spec defines the behaviour of autoscaler. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.","typeRefId":"horizontalpodautoscalerspec-v1-autoscaling","array":false},{"name":"status","description":"status is the current information about the autoscaler.","typeRefId":"horizontalpodautoscalerstatus-v1-autoscaling","array":false}],"appears":[{"typeRefId":"horizontalpodautoscalerlist-v1-autoscaling","text":"HorizontalPodAutoscalerList [autoscaling/v1]"}]},"cronjobspec-v1-batch":{"id":"cronjobspec-v1-batch","name":"CronJobSpec v1 batch","primitive":false,"description":"CronJobSpec v1 batch","fields":[{"name":"concurrencyPolicy","description":"Specifies how to treat concurrent executions of a Job. Valid values are: - \\"Allow\\" (default): allows CronJobs to run concurrently; - \\"Forbid\\": forbids concurrent runs, skipping next run if previous run hasn\'t finished yet; - \\"Replace\\": cancels currently running job and replaces it with a new one Possible enum values: - `\\"Allow\\"` allows CronJobs to run concurrently. - `\\"Forbid\\"` forbids concurrent runs, skipping next run if previous hasn\'t finished yet. - `\\"Replace\\"` cancels currently running job and replaces it with a new one.","typeRefId":"string","array":false},{"name":"failedJobsHistoryLimit","description":"The number of failed finished jobs to retain. Value must be non-negative integer. Defaults to 1.","typeRefId":"integer","array":false},{"name":"jobTemplate","description":"Specifies the job that will be created when executing a CronJob.","typeRefId":"jobtemplatespec-v1-batch","array":false},{"name":"schedule","description":"The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.","typeRefId":"string","array":false},{"name":"startingDeadlineSeconds","description":"Optional deadline in seconds for starting the job if it misses scheduled time for any reason. Missed jobs executions will be counted as failed ones.","typeRefId":"integer","array":false},{"name":"successfulJobsHistoryLimit","description":"The number of successful finished jobs to retain. Value must be non-negative integer. Defaults to 3.","typeRefId":"integer","array":false},{"name":"suspend","description":"This flag tells the controller to suspend subsequent executions, it does not apply to already started executions. Defaults to false.","typeRefId":"boolean","array":false},{"name":"timeZone","description":"The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. If not specified, this will default to the time zone of the kube-controller-manager process. The set of valid time zone names and the time zone offset is loaded from the system-wide time zone database by the API server during CronJob validation and the controller manager during execution. If no system-wide time zone database can be found a bundled version of the database is used instead. If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host configuration, the controller will stop creating new new Jobs and will create a system event with the reason UnknownTimeZone. More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones","typeRefId":"string","array":false}],"appears":[{"typeRefId":"cronjob-v1-batch","text":"CronJob [batch/v1]"}]},"cronjobstatus-v1-batch":{"id":"cronjobstatus-v1-batch","name":"CronJobStatus v1 batch","primitive":false,"description":"CronJobStatus v1 batch","fields":[{"name":"active","description":"A list of pointers to currently running jobs.","typeRefId":"objectreference-v1-core","array":true},{"name":"lastScheduleTime","description":"Information when was the last time the job was successfully scheduled.","typeRefId":"time-v1-meta","array":false},{"name":"lastSuccessfulTime","description":"Information when was the last time the job successfully completed.","typeRefId":"time-v1-meta","array":false}],"appears":[{"typeRefId":"cronjob-v1-batch","text":"CronJob [batch/v1]"}]},"daemonsetspec-v1-apps":{"id":"daemonsetspec-v1-apps","name":"DaemonSetSpec v1 apps","primitive":false,"description":"DaemonSetSpec v1 apps","fields":[{"name":"minReadySeconds","description":"The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).","typeRefId":"integer","array":false},{"name":"revisionHistoryLimit","description":"The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.","typeRefId":"integer","array":false},{"name":"selector","description":"A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template\'s labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","typeRefId":"labelselector-v1-meta","array":false},{"name":"template","description":"An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template\'s node selector (or on every node if no node selector is specified). The only allowed template.spec.restartPolicy value is \\"Always\\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template","typeRefId":"podtemplatespec-v1-core","array":false},{"name":"updateStrategy","description":"An update strategy to replace existing DaemonSet pods with new pods.","typeRefId":"daemonsetupdatestrategy-v1-apps","array":false}],"appears":[{"typeRefId":"daemonset-v1-apps","text":"DaemonSet [apps/v1]"}]},"daemonsetstatus-v1-apps":{"id":"daemonsetstatus-v1-apps","name":"DaemonSetStatus v1 apps","primitive":false,"description":"DaemonSetStatus v1 apps","fields":[{"name":"collisionCount","description":"Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.","typeRefId":"integer","array":false},{"name":"conditions","description":"Represents the latest available observations of a DaemonSet\'s current state.","typeRefId":"daemonsetcondition-v1-apps","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"currentNumberScheduled","description":"The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/","typeRefId":"integer","array":false},{"name":"desiredNumberScheduled","description":"The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/","typeRefId":"integer","array":false},{"name":"numberAvailable","description":"The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)","typeRefId":"integer","array":false},{"name":"numberMisscheduled","description":"The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/","typeRefId":"integer","array":false},{"name":"numberReady","description":"numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.","typeRefId":"integer","array":false},{"name":"numberUnavailable","description":"The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)","typeRefId":"integer","array":false},{"name":"observedGeneration","description":"The most recent generation observed by the daemon set controller.","typeRefId":"integer","array":false},{"name":"updatedNumberScheduled","description":"The total number of nodes that are running updated daemon pod","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"daemonset-v1-apps","text":"DaemonSet [apps/v1]"}]},"deploymentspec-v1-apps":{"id":"deploymentspec-v1-apps","name":"DeploymentSpec v1 apps","primitive":false,"description":"DeploymentSpec v1 apps","fields":[{"name":"minReadySeconds","description":"Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)","typeRefId":"integer","array":false},{"name":"paused","description":"Indicates that the deployment is paused.","typeRefId":"boolean","array":false},{"name":"progressDeadlineSeconds","description":"The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.","typeRefId":"integer","array":false},{"name":"replicas","description":"Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.","typeRefId":"integer","array":false},{"name":"revisionHistoryLimit","description":"The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.","typeRefId":"integer","array":false},{"name":"selector","description":"Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template\'s labels.","typeRefId":"labelselector-v1-meta","array":false},{"name":"strategy","description":"The deployment strategy to use to replace existing pods with new ones.","typeRefId":"deploymentstrategy-v1-apps","array":false,"patch":{"strategy":["retainKeys"]}},{"name":"template","description":"Template describes the pods that will be created. The only allowed template.spec.restartPolicy value is \\"Always\\".","typeRefId":"podtemplatespec-v1-core","array":false}],"appears":[{"typeRefId":"deployment-v1-apps","text":"Deployment [apps/v1]"}]},"deploymentstatus-v1-apps":{"id":"deploymentstatus-v1-apps","name":"DeploymentStatus v1 apps","primitive":false,"description":"DeploymentStatus v1 apps","fields":[{"name":"availableReplicas","description":"Total number of available non-terminating pods (ready for at least minReadySeconds) targeted by this deployment.","typeRefId":"integer","array":false},{"name":"collisionCount","description":"Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.","typeRefId":"integer","array":false},{"name":"conditions","description":"Represents the latest available observations of a deployment\'s current state.","typeRefId":"deploymentcondition-v1-apps","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"observedGeneration","description":"The generation observed by the deployment controller.","typeRefId":"integer","array":false},{"name":"readyReplicas","description":"Total number of non-terminating pods targeted by this Deployment with a Ready Condition.","typeRefId":"integer","array":false},{"name":"replicas","description":"Total number of non-terminating pods targeted by this deployment (their labels match the selector).","typeRefId":"integer","array":false},{"name":"terminatingReplicas","description":"Total number of terminating pods targeted by this deployment. Terminating pods have a non-null .metadata.deletionTimestamp and have not yet reached the Failed or Succeeded .status.phase. This is an alpha field. Enable DeploymentReplicaSetTerminatingReplicas to be able to use this field.","typeRefId":"integer","array":false},{"name":"unavailableReplicas","description":"Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.","typeRefId":"integer","array":false},{"name":"updatedReplicas","description":"Total number of non-terminating pods targeted by this deployment that have the desired template spec.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"deployment-v1-apps","text":"Deployment [apps/v1]"}]},"jobspec-v1-batch":{"id":"jobspec-v1-batch","name":"JobSpec v1 batch","primitive":false,"description":"JobSpec v1 batch","fields":[{"name":"activeDeadlineSeconds","description":"Specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it; value must be positive integer. If a Job is suspended (at creation or through an update), this timer will effectively be stopped and reset when the Job is resumed again.","typeRefId":"integer","array":false},{"name":"backoffLimit","description":"Specifies the number of retries before marking this job failed. Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified. When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.","typeRefId":"integer","array":false},{"name":"backoffLimitPerIndex","description":"Specifies the limit for the number of retries within an index before marking this index as failed. When enabled the number of failures per index is kept in the pod\'s batch.kubernetes.io/job-index-failure-count annotation. It can only be set when Job\'s completionMode=Indexed, and the Pod\'s restart policy is Never. The field is immutable.","typeRefId":"integer","array":false},{"name":"completionMode","description":"completionMode specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. `NonIndexed` means that the Job is considered complete when there have been .spec.completions successfully completed Pods. Each Pod completion is homologous to each other. `Indexed` means that the Pods of a Job get an associated completion index from 0 to (.spec.completions - 1), available in the annotation batch.kubernetes.io/job-completion-index. The Job is considered complete when there is one successfully completed Pod for each index. When value is `Indexed`, .spec.completions must be specified and `.spec.parallelism` must be less than or equal to 10^5. In addition, The Pod name takes the form `$(job-name)-$(index)-$(random-string)`, the Pod hostname takes the form `$(job-name)-$(index)`. More completion modes can be added in the future. If the Job controller observes a mode that it doesn\'t recognize, which is possible during upgrades due to version skew, the controller skips updates for the Job. Possible enum values: - `\\"Indexed\\"` is a Job completion mode. In this mode, the Pods of a Job get an associated completion index from 0 to (.spec.completions - 1). The Job is considered complete when a Pod completes for each completion index. - `\\"NonIndexed\\"` is a Job completion mode. In this mode, the Job is considered complete when there have been .spec.completions successfully completed Pods. Pod completions are homologous to each other.","typeRefId":"string","array":false},{"name":"completions","description":"Specifies the desired number of successfully finished pods the job should be run with. Setting to null means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/","typeRefId":"integer","array":false},{"name":"managedBy","description":"ManagedBy field indicates the controller that manages a Job. The k8s Job controller reconciles jobs which don\'t have this field at all or the field value is the reserved string `kubernetes.io/job-controller`, but skips reconciling Jobs with a custom value for this field. The value must be a valid domain-prefixed path (e.g. acme.io/foo) - all characters before the first \\"/\\" must be a valid subdomain as defined by RFC 1123. All characters trailing the first \\"/\\" must be valid HTTP Path characters as defined by RFC 3986. The value cannot exceed 63 characters. This field is immutable. This field is beta-level. The job controller accepts setting the field when the feature gate JobManagedBy is enabled (enabled by default).","typeRefId":"string","array":false},{"name":"manualSelector","description":"manualSelector controls generation of pod labels and pod selectors. Leave `manualSelector` unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. However, You may see `manualSelector=true` in jobs that were created with the old `extensions/v1beta1` API. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector","typeRefId":"boolean","array":false},{"name":"maxFailedIndexes","description":"Specifies the maximal number of failed indexes before marking the Job as failed, when backoffLimitPerIndex is set. Once the number of failed indexes exceeds this number the entire Job is marked as Failed and its execution is terminated. When left as null the job continues execution of all of its indexes and is marked with the `Complete` Job condition. It can only be specified when backoffLimitPerIndex is set. It can be null or up to completions. It is required and must be less than or equal to 10^4 when is completions greater than 10^5.","typeRefId":"integer","array":false},{"name":"parallelism","description":"Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/","typeRefId":"integer","array":false},{"name":"podFailurePolicy","description":"Specifies the policy of handling failed pods. In particular, it allows to specify the set of actions and conditions which need to be satisfied to take the associated action. If empty, the default behaviour applies - the counter of failed pods, represented by the jobs\'s .status.failed field, is incremented and it is checked against the backoffLimit. This field cannot be used in combination with restartPolicy=OnFailure.","typeRefId":"podfailurepolicy-v1-batch","array":false},{"name":"podReplacementPolicy","description":"podReplacementPolicy specifies when to create replacement Pods. Possible values are: - TerminatingOrFailed means that we recreate pods when they are terminating (has a metadata.deletionTimestamp) or failed. - Failed means to wait until a previously created Pod is fully terminated (has phase Failed or Succeeded) before creating a replacement Pod. When using podFailurePolicy, Failed is the the only allowed value. TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use. Possible enum values: - `\\"Failed\\"` means to wait until a previously created Pod is fully terminated (has phase Failed or Succeeded) before creating a replacement Pod. - `\\"TerminatingOrFailed\\"` means that we recreate pods when they are terminating (has a metadata.deletionTimestamp) or failed.","typeRefId":"string","array":false},{"name":"selector","description":"A label query over pods that should match the pod count. Normally, the system sets this field for you. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","typeRefId":"labelselector-v1-meta","array":false},{"name":"successPolicy","description":"successPolicy specifies the policy when the Job can be declared as succeeded. If empty, the default behavior applies - the Job is declared as succeeded only when the number of succeeded pods equals to the completions. When the field is specified, it must be immutable and works only for the Indexed Jobs. Once the Job meets the SuccessPolicy, the lingering pods are terminated.","typeRefId":"successpolicy-v1-batch","array":false},{"name":"suspend","description":"suspend specifies whether the Job controller should create Pods or not. If a Job is created with suspend set to true, no Pods are created by the Job controller. If a Job is suspended after creation (i.e. the flag goes from false to true), the Job controller will delete all active Pods associated with this Job. Users must design their workload to gracefully handle this. Suspending a Job will reset the StartTime field of the Job, effectively resetting the ActiveDeadlineSeconds timer too. Defaults to false.","typeRefId":"boolean","array":false},{"name":"template","description":"Describes the pod that will be created when executing a job. The only allowed template.spec.restartPolicy values are \\"Never\\" or \\"OnFailure\\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/","typeRefId":"podtemplatespec-v1-core","array":false},{"name":"ttlSecondsAfterFinished","description":"ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won\'t be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"job-v1-batch","text":"Job [batch/v1]"},{"typeRefId":"jobtemplatespec-v1-batch","text":"JobTemplateSpec [batch/v1]"}]},"jobstatus-v1-batch":{"id":"jobstatus-v1-batch","name":"JobStatus v1 batch","primitive":false,"description":"JobStatus v1 batch","fields":[{"name":"active","description":"The number of pending and running pods which are not terminating (without a deletionTimestamp). The value is zero for finished jobs.","typeRefId":"integer","array":false},{"name":"completedIndexes","description":"completedIndexes holds the completed indexes when .spec.completionMode = \\"Indexed\\" in a text format. The indexes are represented as decimal integers separated by commas. The numbers are listed in increasing order. Three or more consecutive numbers are compressed and represented by the first and last element of the series, separated by a hyphen. For example, if the completed indexes are 1, 3, 4, 5 and 7, they are represented as \\"1,3-5,7\\".","typeRefId":"string","array":false},{"name":"completionTime","description":"Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. The completion time is set when the job finishes successfully, and only then. The value cannot be updated or removed. The value indicates the same or later point in time as the startTime field.","typeRefId":"time-v1-meta","array":false},{"name":"conditions","description":"The latest available observations of an object\'s current state. When a Job fails, one of the conditions will have type \\"Failed\\" and status true. When a Job is suspended, one of the conditions will have type \\"Suspended\\" and status true; when the Job is resumed, the status of this condition will become false. When a Job is completed, one of the conditions will have type \\"Complete\\" and status true. A job is considered finished when it is in a terminal condition, either \\"Complete\\" or \\"Failed\\". A Job cannot have both the \\"Complete\\" and \\"Failed\\" conditions. Additionally, it cannot be in the \\"Complete\\" and \\"FailureTarget\\" conditions. The \\"Complete\\", \\"Failed\\" and \\"FailureTarget\\" conditions cannot be disabled. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/","typeRefId":"jobcondition-v1-batch","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"failed","description":"The number of pods which reached phase Failed. The value increases monotonically.","typeRefId":"integer","array":false},{"name":"failedIndexes","description":"FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set. The indexes are represented in the text format analogous as for the `completedIndexes` field, ie. they are kept as decimal integers separated by commas. The numbers are listed in increasing order. Three or more consecutive numbers are compressed and represented by the first and last element of the series, separated by a hyphen. For example, if the failed indexes are 1, 3, 4, 5 and 7, they are represented as \\"1,3-5,7\\". The set of failed indexes cannot overlap with the set of completed indexes.","typeRefId":"string","array":false},{"name":"ready","description":"The number of active pods which have a Ready condition and are not terminating (without a deletionTimestamp).","typeRefId":"integer","array":false},{"name":"startTime","description":"Represents time when the job controller started processing a job. When a Job is created in the suspended state, this field is not set until the first time it is resumed. This field is reset every time a Job is resumed from suspension. It is represented in RFC3339 form and is in UTC. Once set, the field can only be removed when the job is suspended. The field cannot be modified while the job is unsuspended or finished.","typeRefId":"time-v1-meta","array":false},{"name":"succeeded","description":"The number of pods which reached phase Succeeded. The value increases monotonically for a given spec. However, it may decrease in reaction to scale down of elastic indexed jobs.","typeRefId":"integer","array":false},{"name":"terminating","description":"The number of pods which are terminating (in phase Pending or Running and have a deletionTimestamp). This field is beta-level. The job controller populates the field when the feature gate JobPodReplacementPolicy is enabled (enabled by default).","typeRefId":"integer","array":false},{"name":"uncountedTerminatedPods","description":"uncountedTerminatedPods holds the UIDs of Pods that have terminated but the job controller hasn\'t yet accounted for in the status counters. The job controller creates pods with a finalizer. When a pod terminates (succeeded or failed), the controller does three steps to account for it in the job status: 1. Add the pod UID to the arrays in this field. 2. Remove the pod finalizer. 3. Remove the pod UID from the arrays while increasing the corresponding counter. Old jobs might not be tracked using this field, in which case the field remains null. The structure is empty for finished jobs.","typeRefId":"uncountedterminatedpods-v1-batch","array":false}],"appears":[{"typeRefId":"job-v1-batch","text":"Job [batch/v1]"}]},"podspec-v1-core":{"id":"podspec-v1-core","name":"PodSpec v1 core","primitive":false,"description":"PodSpec v1 core","fields":[{"name":"activeDeadlineSeconds","description":"Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.","typeRefId":"integer","array":false},{"name":"affinity","description":"If specified, the pod\'s scheduling constraints","typeRefId":"affinity-v1-core","array":false},{"name":"automountServiceAccountToken","description":"AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.","typeRefId":"boolean","array":false},{"name":"containers","description":"List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.","typeRefId":"container-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"dnsConfig","description":"Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.","typeRefId":"poddnsconfig-v1-core","array":false},{"name":"dnsPolicy","description":"Set DNS policy for the pod. Defaults to \\"ClusterFirst\\". Valid values are \'ClusterFirstWithHostNet\', \'ClusterFirst\', \'Default\' or \'None\'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to \'ClusterFirstWithHostNet\'. Possible enum values: - `\\"ClusterFirst\\"` indicates that the pod should use cluster DNS first unless hostNetwork is true, if it is available, then fall back on the default (as determined by kubelet) DNS settings. - `\\"ClusterFirstWithHostNet\\"` indicates that the pod should use cluster DNS first, if it is available, then fall back on the default (as determined by kubelet) DNS settings. - `\\"Default\\"` indicates that the pod should use the default (as determined by kubelet) DNS settings. - `\\"None\\"` indicates that the pod should use empty DNS settings. DNS parameters such as nameservers and search paths should be defined via DNSConfig.","typeRefId":"string","array":false},{"name":"enableServiceLinks","description":"EnableServiceLinks indicates whether information about services should be injected into pod\'s environment variables, matching the syntax of Docker links. Optional: Defaults to true.","typeRefId":"boolean","array":false},{"name":"ephemeralContainers","description":"List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod\'s ephemeralcontainers subresource.","typeRefId":"ephemeralcontainer-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"hostAliases","description":"HostAliases is an optional list of hosts and IPs that will be injected into the pod\'s hosts file if specified.","typeRefId":"hostalias-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"ip"}},{"name":"hostIPC","description":"Use the host\'s ipc namespace. Optional: Default to false.","typeRefId":"boolean","array":false},{"name":"hostNetwork","description":"Host networking requested for this pod. Use the host\'s network namespace. When using HostNetwork you should specify ports so the scheduler is aware. When `hostNetwork` is true, specified `hostPort` fields in port definitions must match `containerPort`, and unspecified `hostPort` fields in port definitions are defaulted to match `containerPort`. Default to false.","typeRefId":"boolean","array":false},{"name":"hostPID","description":"Use the host\'s pid namespace. Optional: Default to false.","typeRefId":"boolean","array":false},{"name":"hostUsers","description":"Use the host\'s user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.","typeRefId":"boolean","array":false},{"name":"hostname","description":"Specifies the hostname of the Pod If not specified, the pod\'s hostname will be set to a system-defined value.","typeRefId":"string","array":false},{"name":"hostnameOverride","description":"HostnameOverride specifies an explicit override for the pod\'s hostname as perceived by the pod. This field only specifies the pod\'s hostname and does not affect its DNS records. When this field is set to a non-empty string: - It takes precedence over the values set in `hostname` and `subdomain`. - The Pod\'s hostname will be set to this value. - `setHostnameAsFQDN` must be nil or set to false. - `hostNetwork` must be set to false. This field must be a valid DNS subdomain as defined in RFC 1123 and contain at most 64 characters. Requires the HostnameOverride feature gate to be enabled.","typeRefId":"string","array":false},{"name":"imagePullSecrets","description":"ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod","typeRefId":"localobjectreference-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"initContainers","description":"List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/","typeRefId":"container-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"nodeName","description":"NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename","typeRefId":"string","array":false},{"name":"nodeSelector","description":"NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node\'s labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/","typeRefId":"object","array":false},{"name":"os","description":"Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set. If the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.resources - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup","typeRefId":"podos-v1-core","array":false},{"name":"overhead","description":"Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md","typeRefId":"object","array":false},{"name":"preemptionPolicy","description":"PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. Possible enum values: - `\\"Never\\"` means that pod never preempts other pods with lower priority. - `\\"PreemptLowerPriority\\"` means that pod can preempt other pods with lower priority.","typeRefId":"string","array":false},{"name":"priority","description":"The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.","typeRefId":"integer","array":false},{"name":"priorityClassName","description":"If specified, indicates the pod\'s priority. \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.","typeRefId":"string","array":false},{"name":"readinessGates","description":"If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \\"True\\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates","typeRefId":"podreadinessgate-v1-core","array":true},{"name":"resourceClaims","description":"ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable.","typeRefId":"podresourceclaim-v1-core","array":true,"patch":{"strategy":["merge","retainKeys"],"mergeKey":"name"}},{"name":"resources","description":"Resources is the total amount of CPU and Memory resources required by all containers in the pod. It supports specifying Requests and Limits for \\"cpu\\", \\"memory\\" and \\"hugepages-\\" resource names only. ResourceClaims are not supported. This field enables fine-grained control over resource allocation for the entire pod, allowing resource sharing among containers in a pod. This is an alpha field and requires enabling the PodLevelResources feature gate.","typeRefId":"resourcerequirements-v1-core","array":false},{"name":"restartPolicy","description":"Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy Possible enum values: - `\\"Always\\"` - `\\"Never\\"` - `\\"OnFailure\\"`","typeRefId":"string","array":false},{"name":"runtimeClassName","description":"RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod. If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \\"legacy\\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class","typeRefId":"string","array":false},{"name":"schedulerName","description":"If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.","typeRefId":"string","array":false},{"name":"schedulingGates","description":"SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod. SchedulingGates can only be set at pod creation time, and be removed only afterwards.","typeRefId":"podschedulinggate-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"securityContext","description":"SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty. See type description for default values of each field.","typeRefId":"podsecuritycontext-v1-core","array":false},{"name":"serviceAccount","description":"DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.","typeRefId":"string","array":false},{"name":"serviceAccountName","description":"ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/","typeRefId":"string","array":false},{"name":"setHostnameAsFQDN","description":"If true the pod\'s hostname will be configured as the pod\'s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\\\\\SYSTEM\\\\\\\\CurrentControlSet\\\\\\\\Services\\\\\\\\Tcpip\\\\\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.","typeRefId":"boolean","array":false},{"name":"shareProcessNamespace","description":"Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.","typeRefId":"boolean","array":false},{"name":"subdomain","description":"If specified, the fully qualified Pod hostname will be \\"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\\". If not specified, the pod will not have a domainname at all.","typeRefId":"string","array":false},{"name":"terminationGracePeriodSeconds","description":"Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.","typeRefId":"integer","array":false},{"name":"tolerations","description":"If specified, the pod\'s tolerations.","typeRefId":"toleration-v1-core","array":true},{"name":"topologySpreadConstraints","description":"TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.","typeRefId":"topologyspreadconstraint-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"topologyKey"}},{"name":"volumes","description":"List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes","typeRefId":"volume-v1-core","array":true,"patch":{"strategy":["merge","retainKeys"],"mergeKey":"name"}}],"appears":[{"typeRefId":"pod-v1-core","text":"Pod [core/v1]"},{"typeRefId":"podtemplatespec-v1-core","text":"PodTemplateSpec [core/v1]"}]},"podstatus-v1-core":{"id":"podstatus-v1-core","name":"PodStatus v1 core","primitive":false,"description":"PodStatus v1 core","fields":[{"name":"conditions","description":"Current service state of pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions","typeRefId":"podcondition-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"containerStatuses","description":"Statuses of containers in this pod. Each container in the pod should have at most one status in this list, and all statuses should be for containers in the pod. However this is not enforced. If a status for a non-existent container is present in the list, or the list has duplicate names, the behavior of various Kubernetes components is not defined and those statuses might be ignored. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status","typeRefId":"containerstatus-v1-core","array":true},{"name":"ephemeralContainerStatuses","description":"Statuses for any ephemeral containers that have run in this pod. Each ephemeral container in the pod should have at most one status in this list, and all statuses should be for containers in the pod. However this is not enforced. If a status for a non-existent container is present in the list, or the list has duplicate names, the behavior of various Kubernetes components is not defined and those statuses might be ignored. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status","typeRefId":"containerstatus-v1-core","array":true},{"name":"extendedResourceClaimStatus","description":"Status of extended resource claim backed by DRA.","typeRefId":"podextendedresourceclaimstatus-v1-core","array":false},{"name":"hostIP","description":"hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet. A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will not be updated even if there is a node is assigned to pod","typeRefId":"string","array":false},{"name":"hostIPs","description":"hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must match the hostIP field. This list is empty if the pod has not started yet. A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will not be updated even if there is a node is assigned to this pod.","typeRefId":"hostip-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"ip"}},{"name":"initContainerStatuses","description":"Statuses of init containers in this pod. The most recent successful non-restartable init container will have ready = true, the most recently started container will have startTime set. Each init container in the pod should have at most one status in this list, and all statuses should be for containers in the pod. However this is not enforced. If a status for a non-existent container is present in the list, or the list has duplicate names, the behavior of various Kubernetes components is not defined and those statuses might be ignored. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-and-container-status","typeRefId":"containerstatus-v1-core","array":true},{"name":"message","description":"A human readable message indicating details about why the pod is in this condition.","typeRefId":"string","array":false},{"name":"nominatedNodeName","description":"nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be scheduled right away as preemption victims receive their graceful termination periods. This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to give the resources on this node to a higher priority pod that is created after preemption. As a result, this field may be different than PodSpec.nodeName when the pod is scheduled.","typeRefId":"string","array":false},{"name":"observedGeneration","description":"If set, this represents the .metadata.generation that the pod status was set based upon. This is an alpha field. Enable PodObservedGenerationTracking to be able to use this field.","typeRefId":"integer","array":false},{"name":"phase","description":"The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The conditions array, the reason and message fields, and the individual container status arrays contain more detail about the pod\'s status. There are five possible phase values: Pending: The pod has been accepted by the Kubernetes system, but one or more of the container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while. Running: The pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting. Succeeded: All containers in the pod have terminated in success, and will not be restarted. Failed: All containers in the pod have terminated, and at least one container has terminated in failure. The container either exited with non-zero status or was terminated by the system. Unknown: For some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase Possible enum values: - `\\"Failed\\"` means that all containers in the pod have terminated, and at least one container has terminated in a failure (exited with a non-zero exit code or was stopped by the system). - `\\"Pending\\"` means the pod has been accepted by the system, but one or more of the containers has not been started. This includes time before being bound to a node, as well as time spent pulling images onto the host. - `\\"Running\\"` means the pod has been bound to a node and all of the containers have been started. At least one container is still running or is in the process of being restarted. - `\\"Succeeded\\"` means that all containers in the pod have voluntarily terminated with a container exit code of 0, and the system is not going to restart any of these containers. - `\\"Unknown\\"` means that for some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod. Deprecated: It isn\'t being set since 2015 (74da3b14b0c0f658b3bb8d2def5094686d0e9095)","typeRefId":"string","array":false},{"name":"podIP","description":"podIP address allocated to the pod. Routable at least within the cluster. Empty if not yet allocated.","typeRefId":"string","array":false},{"name":"podIPs","description":"podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list is empty if no IPs have been allocated yet.","typeRefId":"podip-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"ip"}},{"name":"qosClass","description":"The Quality of Service (QOS) classification assigned to the pod based on resource requirements See PodQOSClass type for available QOS classes More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes Possible enum values: - `\\"BestEffort\\"` is the BestEffort qos class. - `\\"Burstable\\"` is the Burstable qos class. - `\\"Guaranteed\\"` is the Guaranteed qos class.","typeRefId":"string","array":false},{"name":"reason","description":"A brief CamelCase message indicating details about why the pod is in this state. e.g. \'Evicted\'","typeRefId":"string","array":false},{"name":"resize","description":"Status of resources resize desired for pod\'s containers. It is empty if no resources resize is pending. Any changes to container resources will automatically set this to \\"Proposed\\" Deprecated: Resize status is moved to two pod conditions PodResizePending and PodResizeInProgress. PodResizePending will track states where the spec has been resized, but the Kubelet has not yet allocated the resources. PodResizeInProgress will track in-progress resizes, and should be present whenever allocated resources != acknowledged resources.","typeRefId":"string","array":false},{"name":"resourceClaimStatuses","description":"Status of resource claims.","typeRefId":"podresourceclaimstatus-v1-core","array":true,"patch":{"strategy":["merge","retainKeys"],"mergeKey":"name"}},{"name":"startTime","description":"RFC 3339 date and time at which the object was acknowledged by the Kubelet. This is before the Kubelet pulled the container image(s) for the pod.","typeRefId":"time-v1-meta","array":false}],"appears":[{"typeRefId":"pod-v1-core","text":"Pod [core/v1]"}]},"replicasetspec-v1-apps":{"id":"replicasetspec-v1-apps","name":"ReplicaSetSpec v1 apps","primitive":false,"description":"ReplicaSetSpec v1 apps","fields":[{"name":"minReadySeconds","description":"Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)","typeRefId":"integer","array":false},{"name":"replicas","description":"Replicas is the number of desired pods. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset","typeRefId":"integer","array":false},{"name":"selector","description":"Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template\'s labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","typeRefId":"labelselector-v1-meta","array":false},{"name":"template","description":"Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#pod-template","typeRefId":"podtemplatespec-v1-core","array":false}],"appears":[{"typeRefId":"replicaset-v1-apps","text":"ReplicaSet [apps/v1]"}]},"replicasetstatus-v1-apps":{"id":"replicasetstatus-v1-apps","name":"ReplicaSetStatus v1 apps","primitive":false,"description":"ReplicaSetStatus v1 apps","fields":[{"name":"availableReplicas","description":"The number of available non-terminating pods (ready for at least minReadySeconds) for this replica set.","typeRefId":"integer","array":false},{"name":"conditions","description":"Represents the latest available observations of a replica set\'s current state.","typeRefId":"replicasetcondition-v1-apps","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"fullyLabeledReplicas","description":"The number of non-terminating pods that have labels matching the labels of the pod template of the replicaset.","typeRefId":"integer","array":false},{"name":"observedGeneration","description":"ObservedGeneration reflects the generation of the most recently observed ReplicaSet.","typeRefId":"integer","array":false},{"name":"readyReplicas","description":"The number of non-terminating pods targeted by this ReplicaSet with a Ready Condition.","typeRefId":"integer","array":false},{"name":"replicas","description":"Replicas is the most recently observed number of non-terminating pods. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset","typeRefId":"integer","array":false},{"name":"terminatingReplicas","description":"The number of terminating pods for this replica set. Terminating pods have a non-null .metadata.deletionTimestamp and have not yet reached the Failed or Succeeded .status.phase. This is an alpha field. Enable DeploymentReplicaSetTerminatingReplicas to be able to use this field.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"replicaset-v1-apps","text":"ReplicaSet [apps/v1]"}]},"replicationcontrollerspec-v1-core":{"id":"replicationcontrollerspec-v1-core","name":"ReplicationControllerSpec v1 core","primitive":false,"description":"ReplicationControllerSpec v1 core","fields":[{"name":"minReadySeconds","description":"Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)","typeRefId":"integer","array":false},{"name":"replicas","description":"Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller","typeRefId":"integer","array":false},{"name":"selector","description":"Selector is a label query over pods that should match the Replicas count. If Selector is empty, it is defaulted to the labels present on the Pod template. Label keys and values that must match in order to be controlled by this replication controller, if empty defaulted to labels on Pod template. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","typeRefId":"object","array":false},{"name":"template","description":"Template is the object that describes the pod that will be created if insufficient replicas are detected. This takes precedence over a TemplateRef. The only allowed template.spec.restartPolicy value is \\"Always\\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template","typeRefId":"podtemplatespec-v1-core","array":false}],"appears":[{"typeRefId":"replicationcontroller-v1-core","text":"ReplicationController [core/v1]"}]},"replicationcontrollerstatus-v1-core":{"id":"replicationcontrollerstatus-v1-core","name":"ReplicationControllerStatus v1 core","primitive":false,"description":"ReplicationControllerStatus v1 core","fields":[{"name":"availableReplicas","description":"The number of available replicas (ready for at least minReadySeconds) for this replication controller.","typeRefId":"integer","array":false},{"name":"conditions","description":"Represents the latest available observations of a replication controller\'s current state.","typeRefId":"replicationcontrollercondition-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"fullyLabeledReplicas","description":"The number of pods that have labels matching the labels of the pod template of the replication controller.","typeRefId":"integer","array":false},{"name":"observedGeneration","description":"ObservedGeneration reflects the generation of the most recently observed replication controller.","typeRefId":"integer","array":false},{"name":"readyReplicas","description":"The number of ready replicas for this replication controller.","typeRefId":"integer","array":false},{"name":"replicas","description":"Replicas is the most recently observed number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"replicationcontroller-v1-core","text":"ReplicationController [core/v1]"}]},"statefulsetspec-v1-apps":{"id":"statefulsetspec-v1-apps","name":"StatefulSetSpec v1 apps","primitive":false,"description":"StatefulSetSpec v1 apps","fields":[{"name":"minReadySeconds","description":"Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)","typeRefId":"integer","array":false},{"name":"ordinals","description":"ordinals controls the numbering of replica indices in a StatefulSet. The default ordinals behavior assigns a \\"0\\" index to the first replica and increments the index by one for each additional replica requested.","typeRefId":"statefulsetordinals-v1-apps","array":false},{"name":"persistentVolumeClaimRetentionPolicy","description":"persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down.","typeRefId":"statefulsetpersistentvolumeclaimretentionpolicy-v1-apps","array":false},{"name":"podManagementPolicy","description":"podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. Possible enum values: - `\\"OrderedReady\\"` will create pods in strictly increasing order on scale up and strictly decreasing order on scale down, progressing only when the previous pod is ready or terminated. At most one pod will be changed at any time. - `\\"Parallel\\"` will create and delete pods as soon as the stateful set replica count is changed, and will not wait for pods to be ready or complete termination.","typeRefId":"string","array":false},{"name":"replicas","description":"replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.","typeRefId":"integer","array":false},{"name":"revisionHistoryLimit","description":"revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet\'s revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.","typeRefId":"integer","array":false},{"name":"selector","description":"selector is a label query over pods that should match the replica count. It must match the pod template\'s labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","typeRefId":"labelselector-v1-meta","array":false},{"name":"serviceName","description":"serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \\"pod-specific-string\\" is managed by the StatefulSet controller.","typeRefId":"string","array":false},{"name":"template","description":"template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet. Each pod will be named with the format <statefulsetname>-<podindex>. For example, a pod in a StatefulSet named \\"web\\" with index number \\"3\\" would be named \\"web-3\\". The only allowed template.spec.restartPolicy value is \\"Always\\".","typeRefId":"podtemplatespec-v1-core","array":false},{"name":"updateStrategy","description":"updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.","typeRefId":"statefulsetupdatestrategy-v1-apps","array":false},{"name":"volumeClaimTemplates","description":"volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.","typeRefId":"persistentvolumeclaim-v1-core","array":true}],"appears":[{"typeRefId":"statefulset-v1-apps","text":"StatefulSet [apps/v1]"}]},"statefulsetstatus-v1-apps":{"id":"statefulsetstatus-v1-apps","name":"StatefulSetStatus v1 apps","primitive":false,"description":"StatefulSetStatus v1 apps","fields":[{"name":"availableReplicas","description":"Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.","typeRefId":"integer","array":false},{"name":"collisionCount","description":"collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.","typeRefId":"integer","array":false},{"name":"conditions","description":"Represents the latest available observations of a statefulset\'s current state.","typeRefId":"statefulsetcondition-v1-apps","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"currentReplicas","description":"currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.","typeRefId":"integer","array":false},{"name":"currentRevision","description":"currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).","typeRefId":"string","array":false},{"name":"observedGeneration","description":"observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet\'s generation, which is updated on mutation by the API Server.","typeRefId":"integer","array":false},{"name":"readyReplicas","description":"readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.","typeRefId":"integer","array":false},{"name":"replicas","description":"replicas is the number of Pods created by the StatefulSet controller.","typeRefId":"integer","array":false},{"name":"updateRevision","description":"updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)","typeRefId":"string","array":false},{"name":"updatedReplicas","description":"updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"statefulset-v1-apps","text":"StatefulSet [apps/v1]"}]},"servicespec-v1-core":{"id":"servicespec-v1-core","name":"ServiceSpec v1 core","primitive":false,"description":"ServiceSpec v1 core","fields":[{"name":"allocateLoadBalancerNodePorts","description":"allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer. Default is \\"true\\". It may be set to \\"false\\" if the cluster load-balancer does not rely on NodePorts. If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.","typeRefId":"boolean","array":false},{"name":"clusterIP","description":"clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above). Valid values are \\"None\\", empty string (\\"\\"), or a valid IP address. Setting this to \\"None\\" makes a \\"headless service\\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies","typeRefId":"string","array":false},{"name":"clusterIPs","description":"ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above). Valid values are \\"None\\", empty string (\\"\\"), or a valid IP address. Setting this to \\"None\\" makes a \\"headless service\\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. If this field is not specified, it will be initialized from the clusterIP field. If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies","typeRefId":"string","array":true},{"name":"externalIPs","description":"externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system.","typeRefId":"string","array":true},{"name":"externalName","description":"externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved. Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be \\"ExternalName\\".","typeRefId":"string","array":false},{"name":"externalTrafficPolicy","description":"externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service\'s \\"externally-facing\\" addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to \\"Local\\", the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, \\"Cluster\\", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get \\"Cluster\\" semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node. Possible enum values: - `\\"Cluster\\"` routes traffic to all endpoints. - `\\"Local\\"` preserves the source IP of the traffic by routing only to endpoints on the same node as the traffic was received on (dropping the traffic if there are no local endpoints).","typeRefId":"string","array":false},{"name":"healthCheckNodePort","description":"healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used. If not specified, a value will be automatically allocated. External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not. If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type). This field cannot be updated once set.","typeRefId":"integer","array":false},{"name":"internalTrafficPolicy","description":"InternalTrafficPolicy describes how nodes distribute service traffic they receive on the ClusterIP. If set to \\"Local\\", the proxy will assume that pods only want to talk to endpoints of the service on the same node as the pod, dropping the traffic if there are no local endpoints. The default value, \\"Cluster\\", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Possible enum values: - `\\"Cluster\\"` routes traffic to all endpoints. - `\\"Local\\"` routes traffic only to endpoints on the same node as the client pod (dropping the traffic if there are no local endpoints).","typeRefId":"string","array":false},{"name":"ipFamilies","description":"IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \\"IPv4\\" and \\"IPv6\\". This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \\"headless\\" services. This field will be wiped when updating a Service to type ExternalName. This field may hold a maximum of two entries (dual-stack families, in either order). These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.","typeRefId":"string","array":true},{"name":"ipFamilyPolicy","description":"IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be \\"SingleStack\\" (a single IP family), \\"PreferDualStack\\" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or \\"RequireDualStack\\" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName. Possible enum values: - `\\"PreferDualStack\\"` indicates that this service prefers dual-stack when the cluster is configured for dual-stack. If the cluster is not configured for dual-stack the service will be assigned a single IPFamily. If the IPFamily is not set in service.spec.ipFamilies then the service will be assigned the default IPFamily configured on the cluster - `\\"RequireDualStack\\"` indicates that this service requires dual-stack. Using IPFamilyPolicyRequireDualStack on a single stack cluster will result in validation errors. The IPFamilies (and their order) assigned to this service is based on service.spec.ipFamilies. If service.spec.ipFamilies was not provided then it will be assigned according to how they are configured on the cluster. If service.spec.ipFamilies has only one entry then the alternative IPFamily will be added by apiserver - `\\"SingleStack\\"` indicates that this service is required to have a single IPFamily. The IPFamily assigned is based on the default IPFamily used by the cluster or as identified by service.spec.ipFamilies field","typeRefId":"string","array":false},{"name":"loadBalancerClass","description":"loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. \\"internal-vip\\" or \\"example.com/internal-vip\\". Unprefixed names are reserved for end-users. This field can only be set when the Service type is \'LoadBalancer\'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type \'LoadBalancer\'. Once set, it can not be changed. This field will be wiped when a service is updated to a non \'LoadBalancer\' type.","typeRefId":"string","array":false},{"name":"loadBalancerIP","description":"Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations. Using it is non-portable and it may not support dual-stack. Users are encouraged to use implementation-specific annotations when available.","typeRefId":"string","array":false},{"name":"loadBalancerSourceRanges","description":"If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.\\" More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/","typeRefId":"string","array":true},{"name":"ports","description":"The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies","typeRefId":"serviceport-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"port"}},{"name":"publishNotReadyAddresses","description":"publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet\'s Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered \\"ready\\" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.","typeRefId":"boolean","array":false},{"name":"selector","description":"Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/","typeRefId":"object","array":false},{"name":"sessionAffinity","description":"Supports \\"ClientIP\\" and \\"None\\". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies Possible enum values: - `\\"ClientIP\\"` is the Client IP based. - `\\"None\\"` - no session affinity.","typeRefId":"string","array":false},{"name":"sessionAffinityConfig","description":"sessionAffinityConfig contains the configurations of session affinity.","typeRefId":"sessionaffinityconfig-v1-core","array":false},{"name":"trafficDistribution","description":"TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to \\"PreferClose\\", implementations should prioritize endpoints that are in the same zone.","typeRefId":"string","array":false},{"name":"type","description":"type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \\"ClusterIP\\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is \\"None\\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. \\"NodePort\\" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. \\"LoadBalancer\\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. \\"ExternalName\\" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Possible enum values: - `\\"ClusterIP\\"` means a service will only be accessible inside the cluster, via the cluster IP. - `\\"ExternalName\\"` means a service consists of only a reference to an external name that kubedns or equivalent will return as a CNAME record, with no exposing or proxying of any pods involved. - `\\"LoadBalancer\\"` means a service will be exposed via an external load balancer (if the cloud provider supports it), in addition to \'NodePort\' type. - `\\"NodePort\\"` means a service will be exposed on one port of every node, in addition to \'ClusterIP\' type.","typeRefId":"string","array":false}],"appears":[{"typeRefId":"service-v1-core","text":"Service [core/v1]"}]},"servicestatus-v1-core":{"id":"servicestatus-v1-core","name":"ServiceStatus v1 core","primitive":false,"description":"ServiceStatus v1 core","fields":[{"name":"conditions","description":"Current service state","typeRefId":"condition-v1-meta","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"loadBalancer","description":"LoadBalancer contains the current status of the load-balancer, if one is present.","typeRefId":"loadbalancerstatus-v1-core","array":false}],"appears":[{"typeRefId":"service-v1-core","text":"Service [core/v1]"}]},"persistentvolumeclaimspec-v1-core":{"id":"persistentvolumeclaimspec-v1-core","name":"PersistentVolumeClaimSpec v1 core","primitive":false,"description":"PersistentVolumeClaimSpec v1 core","fields":[{"name":"accessModes","description":"accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1","typeRefId":"string","array":true},{"name":"dataSource","description":"dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.","typeRefId":"typedlocalobjectreference-v1-core","array":false},{"name":"dataSourceRef","description":"dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn\'t specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn\'t set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.","typeRefId":"typedobjectreference-v1-core","array":false},{"name":"resources","description":"resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources","typeRefId":"volumeresourcerequirements-v1-core","array":false},{"name":"selector","description":"selector is a label query over volumes to consider for binding.","typeRefId":"labelselector-v1-meta","array":false},{"name":"storageClassName","description":"storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1","typeRefId":"string","array":false},{"name":"volumeAttributesClassName","description":"volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string or nil value indicates that no VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state, this field can be reset to its previous value (including nil) to cancel the modification. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/","typeRefId":"string","array":false},{"name":"volumeMode","description":"volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. Possible enum values: - `\\"Block\\"` means the volume will not be formatted with a filesystem and will remain a raw block device. - `\\"Filesystem\\"` means the volume will be or is formatted with a filesystem.","typeRefId":"string","array":false},{"name":"volumeName","description":"volumeName is the binding reference to the PersistentVolume backing this claim.","typeRefId":"string","array":false}],"appears":[{"typeRefId":"persistentvolumeclaim-v1-core","text":"PersistentVolumeClaim [core/v1]"},{"typeRefId":"persistentvolumeclaimtemplate-v1-core","text":"PersistentVolumeClaimTemplate [core/v1]"}]},"persistentvolumeclaimstatus-v1-core":{"id":"persistentvolumeclaimstatus-v1-core","name":"PersistentVolumeClaimStatus v1 core","primitive":false,"description":"PersistentVolumeClaimStatus v1 core","fields":[{"name":"accessModes","description":"accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1","typeRefId":"string","array":true},{"name":"allocatedResourceStatuses","description":"allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as \\"example.com/my-custom-resource\\" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used. ClaimResourceStatus can be in any of following states: - ControllerResizeInProgress: State set when resize controller starts resizing the volume in control-plane. - ControllerResizeFailed: State set when resize has failed in resize controller with a terminal error. - NodeResizePending: State set when resize controller has finished resizing the volume but further resizing of volume is needed on the node. - NodeResizeInProgress: State set when kubelet starts resizing the volume. - NodeResizeFailed: State set when resizing has failed in kubelet with a terminal error. Transient errors don\'t set NodeResizeFailed. For example: if expanding a PVC for more capacity - this field can be one of the following states: - pvc.status.allocatedResourceStatus[\'storage\'] = \\"ControllerResizeInProgress\\" - pvc.status.allocatedResourceStatus[\'storage\'] = \\"ControllerResizeFailed\\" - pvc.status.allocatedResourceStatus[\'storage\'] = \\"NodeResizePending\\" - pvc.status.allocatedResourceStatus[\'storage\'] = \\"NodeResizeInProgress\\" - pvc.status.allocatedResourceStatus[\'storage\'] = \\"NodeResizeFailed\\" When this field is not set, it means that no resize operation is in progress for the given PVC. A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.","typeRefId":"object","array":false},{"name":"allocatedResources","description":"allocatedResources tracks the resources allocated to a PVC including its capacity. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as \\"example.com/my-custom-resource\\" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used. Capacity reported here may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity. A controller that receives PVC update with previously unknown resourceName should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.","typeRefId":"object","array":false},{"name":"capacity","description":"capacity represents the actual resources of the underlying volume.","typeRefId":"object","array":false},{"name":"conditions","description":"conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to \'Resizing\'.","typeRefId":"persistentvolumeclaimcondition-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"currentVolumeAttributesClassName","description":"currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using. When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim","typeRefId":"string","array":false},{"name":"modifyVolumeStatus","description":"ModifyVolumeStatus represents the status object of ControllerModifyVolume operation. When this is unset, there is no ModifyVolume operation being attempted.","typeRefId":"modifyvolumestatus-v1-core","array":false},{"name":"phase","description":"phase represents the current phase of PersistentVolumeClaim. Possible enum values: - `\\"Bound\\"` used for PersistentVolumeClaims that are bound - `\\"Lost\\"` used for PersistentVolumeClaims that lost their underlying PersistentVolume. The claim was bound to a PersistentVolume and this volume does not exist any longer and all data on it was lost. - `\\"Pending\\"` used for PersistentVolumeClaims that are not yet bound","typeRefId":"string","array":false}],"appears":[{"typeRefId":"persistentvolumeclaim-v1-core","text":"PersistentVolumeClaim [core/v1]"}]},"limitrangespec-v1-core":{"id":"limitrangespec-v1-core","name":"LimitRangeSpec v1 core","primitive":false,"description":"LimitRangeSpec v1 core","fields":[{"name":"limits","description":"Limits is the list of LimitRangeItem objects that are enforced.","typeRefId":"limitrangeitem-v1-core","array":true}],"appears":[{"typeRefId":"limitrange-v1-core","text":"LimitRange [core/v1]"}]},"horizontalpodautoscalerspec-v2-autoscaling":{"id":"horizontalpodautoscalerspec-v2-autoscaling","name":"HorizontalPodAutoscalerSpec v2 autoscaling","primitive":false,"description":"HorizontalPodAutoscalerSpec v2 autoscaling","fields":[{"name":"behavior","description":"behavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively). If not set, the default HPAScalingRules for scale up and scale down are used.","typeRefId":"horizontalpodautoscalerbehavior-v2-autoscaling","array":false},{"name":"maxReplicas","description":"maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.","typeRefId":"integer","array":false},{"name":"metrics","description":"metrics contains the specifications for which to use to calculate the desired replica count (the maximum replica count across all metrics will be used). The desired replica count is calculated multiplying the ratio between the target value and the current value by the current number of pods. Ergo, metrics used must decrease as the pod count is increased, and vice-versa. See the individual metric source types for more information about how each type of metric must respond. If not set, the default metric will be set to 80% average CPU utilization.","typeRefId":"metricspec-v2-autoscaling","array":true},{"name":"minReplicas","description":"minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down. It defaults to 1 pod. minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured. Scaling is active as long as at least one metric value is available.","typeRefId":"integer","array":false},{"name":"scaleTargetRef","description":"scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics should be collected, as well as to actually change the replica count.","typeRefId":"crossversionobjectreference-v2-autoscaling","array":false}],"appears":[{"typeRefId":"horizontalpodautoscaler-v2-autoscaling","text":"HorizontalPodAutoscaler [autoscaling/v2]"}]},"horizontalpodautoscalerstatus-v2-autoscaling":{"id":"horizontalpodautoscalerstatus-v2-autoscaling","name":"HorizontalPodAutoscalerStatus v2 autoscaling","primitive":false,"description":"HorizontalPodAutoscalerStatus v2 autoscaling","fields":[{"name":"conditions","description":"conditions is the set of conditions required for this autoscaler to scale its target, and indicates whether or not those conditions are met.","typeRefId":"horizontalpodautoscalercondition-v2-autoscaling","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"currentMetrics","description":"currentMetrics is the last read state of the metrics used by this autoscaler.","typeRefId":"metricstatus-v2-autoscaling","array":true},{"name":"currentReplicas","description":"currentReplicas is current number of replicas of pods managed by this autoscaler, as last seen by the autoscaler.","typeRefId":"integer","array":false},{"name":"desiredReplicas","description":"desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as last calculated by the autoscaler.","typeRefId":"integer","array":false},{"name":"lastScaleTime","description":"lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods, used by the autoscaler to control how often the number of pods is changed.","typeRefId":"time-v1-meta","array":false},{"name":"observedGeneration","description":"observedGeneration is the most recent generation observed by this autoscaler.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"horizontalpodautoscaler-v2-autoscaling","text":"HorizontalPodAutoscaler [autoscaling/v2]"}]},"podtemplatespec-v1-core":{"id":"podtemplatespec-v1-core","name":"PodTemplateSpec v1 core","primitive":false,"description":"PodTemplateSpec v1 core","fields":[{"name":"metadata","description":"Standard object\'s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","typeRefId":"objectmeta-v1-meta","array":false},{"name":"spec","description":"Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","typeRefId":"podspec-v1-core","array":false}],"appears":[{"typeRefId":"daemonsetspec-v1-apps","text":"DaemonSetSpec [apps/v1]"},{"typeRefId":"deploymentspec-v1-apps","text":"DeploymentSpec [apps/v1]"},{"typeRefId":"jobspec-v1-batch","text":"JobSpec [batch/v1]"},{"typeRefId":"podtemplate-v1-core","text":"PodTemplate [core/v1]"},{"typeRefId":"replicasetspec-v1-apps","text":"ReplicaSetSpec [apps/v1]"},{"typeRefId":"replicationcontrollerspec-v1-core","text":"ReplicationControllerSpec [core/v1]"},{"typeRefId":"statefulsetspec-v1-apps","text":"StatefulSetSpec [apps/v1]"}]},"poddisruptionbudgetspec-v1-policy":{"id":"poddisruptionbudgetspec-v1-policy","name":"PodDisruptionBudgetSpec v1 policy","primitive":false,"description":"PodDisruptionBudgetSpec v1 policy","fields":[{"name":"maxUnavailable","description":"An eviction is allowed if at most \\"maxUnavailable\\" pods selected by \\"selector\\" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with \\"minAvailable\\".","array":false},{"name":"minAvailable","description":"An eviction is allowed if at least \\"minAvailable\\" pods selected by \\"selector\\" will still be available after the eviction, i.e. even in the absence of the evicted pod. So for example you can prevent all voluntary evictions by specifying \\"100%\\".","array":false},{"name":"selector","description":"Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.","typeRefId":"labelselector-v1-meta","array":false,"patch":{"strategy":["replace"]}},{"name":"unhealthyPodEvictionPolicy","description":"UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type=\\"Ready\\",status=\\"True\\". Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy. IfHealthyBudget policy means that running pods (status.phase=\\"Running\\"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction. AlwaysAllow policy means that all running pods (status.phase=\\"Running\\"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction. Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field. Possible enum values: - `\\"AlwaysAllow\\"` policy means that all running pods (status.phase=\\"Running\\"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction. - `\\"IfHealthyBudget\\"` policy means that running pods (status.phase=\\"Running\\"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.","typeRefId":"string","array":false}],"appears":[{"typeRefId":"poddisruptionbudget-v1-policy","text":"PodDisruptionBudget [policy/v1]"}]},"poddisruptionbudgetstatus-v1-policy":{"id":"poddisruptionbudgetstatus-v1-policy","name":"PodDisruptionBudgetStatus v1 policy","primitive":false,"description":"PodDisruptionBudgetStatus v1 policy","fields":[{"name":"conditions","description":"Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn\'t able to compute the number of allowed disruptions. Therefore no disruptions are allowed and the status of the condition will be False. - InsufficientPods: The number of pods are either at or below the number required by the PodDisruptionBudget. No disruptions are allowed and the status of the condition will be False. - SufficientPods: There are more pods than required by the PodDisruptionBudget. The condition will be True, and the number of allowed disruptions are provided by the disruptionsAllowed property.","typeRefId":"condition-v1-meta","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"currentHealthy","description":"current number of healthy pods","typeRefId":"integer","array":false},{"name":"desiredHealthy","description":"minimum desired number of healthy pods","typeRefId":"integer","array":false},{"name":"disruptedPods","description":"DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn\'t occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.","typeRefId":"object","array":false},{"name":"disruptionsAllowed","description":"Number of pod disruptions that are currently allowed.","typeRefId":"integer","array":false},{"name":"expectedPods","description":"total number of pods counted by this disruption budget","typeRefId":"integer","array":false},{"name":"observedGeneration","description":"Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB\'s object generation.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"poddisruptionbudget-v1-policy","text":"PodDisruptionBudget [policy/v1]"}]},"namespacespec-v1-core":{"id":"namespacespec-v1-core","name":"NamespaceSpec v1 core","primitive":false,"description":"NamespaceSpec v1 core","fields":[{"name":"finalizers","description":"Finalizers is an opaque list of values that must be empty to permanently remove object from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/","typeRefId":"string","array":true}],"appears":[{"typeRefId":"namespace-v1-core","text":"Namespace [core/v1]"}]},"namespacestatus-v1-core":{"id":"namespacestatus-v1-core","name":"NamespaceStatus v1 core","primitive":false,"description":"NamespaceStatus v1 core","fields":[{"name":"conditions","description":"Represents the latest available observations of a namespace\'s current state.","typeRefId":"namespacecondition-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"phase","description":"Phase is the current lifecycle phase of the namespace. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/ Possible enum values: - `\\"Active\\"` means the namespace is available for use in the system - `\\"Terminating\\"` means the namespace is undergoing graceful termination","typeRefId":"string","array":false}],"appears":[{"typeRefId":"namespace-v1-core","text":"Namespace [core/v1]"}]},"nodespec-v1-core":{"id":"nodespec-v1-core","name":"NodeSpec v1 core","primitive":false,"description":"NodeSpec v1 core","fields":[{"name":"configSource","description":"Deprecated: Previously used to specify the source of the node\'s configuration for the DynamicKubeletConfig feature. This feature is removed.","typeRefId":"nodeconfigsource-v1-core","array":false},{"name":"externalID","description":"Deprecated. Not all kubelets will set this field. Remove field after 1.13. see: https://issues.k8s.io/61966","typeRefId":"string","array":false},{"name":"podCIDR","description":"PodCIDR represents the pod IP range assigned to the node.","typeRefId":"string","array":false},{"name":"podCIDRs","description":"podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for each of IPv4 and IPv6.","typeRefId":"string","array":true,"patch":{"strategy":["merge"]}},{"name":"providerID","description":"ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>","typeRefId":"string","array":false},{"name":"taints","description":"If specified, the node\'s taints.","typeRefId":"taint-v1-core","array":true},{"name":"unschedulable","description":"Unschedulable controls node schedulability of new pods. By default, node is schedulable. More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration","typeRefId":"boolean","array":false}],"appears":[{"typeRefId":"node-v1-core","text":"Node [core/v1]"}]},"nodestatus-v1-core":{"id":"nodestatus-v1-core","name":"NodeStatus v1 core","primitive":false,"description":"NodeStatus v1 core","fields":[{"name":"addresses","description":"List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/reference/node/node-status/#addresses Note: This field is declared as mergeable, but the merge key is not sufficiently unique, which can cause data corruption when it is merged. Callers should instead use a full-replacement patch. See https://pr.k8s.io/79391 for an example. Consumers should assume that addresses can change during the lifetime of a Node. However, there are some exceptions where this may not be possible, such as Pods that inherit a Node\'s address in its own status or consumers of the downward API (status.hostIP).","typeRefId":"nodeaddress-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"allocatable","description":"Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.","typeRefId":"object","array":false},{"name":"capacity","description":"Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/reference/node/node-status/#capacity","typeRefId":"object","array":false},{"name":"conditions","description":"Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/reference/node/node-status/#condition","typeRefId":"nodecondition-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"type"}},{"name":"config","description":"Status of the config assigned to the node via the dynamic Kubelet config feature.","typeRefId":"nodeconfigstatus-v1-core","array":false},{"name":"daemonEndpoints","description":"Endpoints of daemons running on the Node.","typeRefId":"nodedaemonendpoints-v1-core","array":false},{"name":"features","description":"Features describes the set of features implemented by the CRI implementation.","typeRefId":"nodefeatures-v1-core","array":false},{"name":"images","description":"List of container images on this node","typeRefId":"containerimage-v1-core","array":true},{"name":"nodeInfo","description":"Set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/reference/node/node-status/#info","typeRefId":"nodesysteminfo-v1-core","array":false},{"name":"phase","description":"NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated. Possible enum values: - `\\"Pending\\"` means the node has been created/added by the system, but not configured. - `\\"Running\\"` means the node has been configured and has Kubernetes components running. - `\\"Terminated\\"` means the node has been removed from the cluster.","typeRefId":"string","array":false},{"name":"runtimeHandlers","description":"The available runtime handlers.","typeRefId":"noderuntimehandler-v1-core","array":true},{"name":"volumesAttached","description":"List of volumes that are attached to the node.","typeRefId":"attachedvolume-v1-core","array":true},{"name":"volumesInUse","description":"List of attachable volumes in use (mounted) by the node.","typeRefId":"string","array":true}],"appears":[{"typeRefId":"node-v1-core","text":"Node [core/v1]"}]},"persistentvolumespec-v1-core":{"id":"persistentvolumespec-v1-core","name":"PersistentVolumeSpec v1 core","primitive":false,"description":"PersistentVolumeSpec v1 core","fields":[{"name":"accessModes","description":"accessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes","typeRefId":"string","array":true},{"name":"awsElasticBlockStore","description":"awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet\'s host machine and then exposed to the pod. Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","typeRefId":"awselasticblockstorevolumesource-v1-core","array":false},{"name":"azureDisk","description":"azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type are redirected to the disk.csi.azure.com CSI driver.","typeRefId":"azurediskvolumesource-v1-core","array":false},{"name":"azureFile","description":"azureFile represents an Azure File Service mount on the host and bind mount to the pod. Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type are redirected to the file.csi.azure.com CSI driver.","typeRefId":"azurefilepersistentvolumesource-v1-core","array":false},{"name":"capacity","description":"capacity is the description of the persistent volume\'s resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity","typeRefId":"object","array":false},{"name":"cephfs","description":"cephFS represents a Ceph FS mount on the host that shares a pod\'s lifetime. Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.","typeRefId":"cephfspersistentvolumesource-v1-core","array":false},{"name":"cinder","description":"cinder represents a cinder volume attached and mounted on kubelets host machine. Deprecated: Cinder is deprecated. All operations for the in-tree cinder type are redirected to the cinder.csi.openstack.org CSI driver. More info: https://examples.k8s.io/mysql-cinder-pd/README.md","typeRefId":"cinderpersistentvolumesource-v1-core","array":false},{"name":"claimRef","description":"claimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding","typeRefId":"objectreference-v1-core","array":false},{"name":"csi","description":"csi represents storage that is handled by an external CSI driver.","typeRefId":"csipersistentvolumesource-v1-core","array":false},{"name":"fc","description":"fc represents a Fibre Channel resource that is attached to a kubelet\'s host machine and then exposed to the pod.","typeRefId":"fcvolumesource-v1-core","array":false},{"name":"flexVolume","description":"flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.","typeRefId":"flexpersistentvolumesource-v1-core","array":false},{"name":"flocker","description":"flocker represents a Flocker volume attached to a kubelet\'s host machine and exposed to the pod for its usage. This depends on the Flocker control service being running. Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.","typeRefId":"flockervolumesource-v1-core","array":false},{"name":"gcePersistentDisk","description":"gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet\'s host machine and then exposed to the pod. Provisioned by an admin. Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","typeRefId":"gcepersistentdiskvolumesource-v1-core","array":false},{"name":"glusterfs","description":"glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported. More info: https://examples.k8s.io/volumes/glusterfs/README.md","typeRefId":"glusterfspersistentvolumesource-v1-core","array":false},{"name":"hostPath","description":"hostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath","typeRefId":"hostpathvolumesource-v1-core","array":false},{"name":"iscsi","description":"iscsi represents an ISCSI Disk resource that is attached to a kubelet\'s host machine and then exposed to the pod. Provisioned by an admin.","typeRefId":"iscsipersistentvolumesource-v1-core","array":false},{"name":"local","description":"local represents directly-attached storage with node affinity","typeRefId":"localvolumesource-v1-core","array":false},{"name":"mountOptions","description":"mountOptions is the list of mount options, e.g. [\\"ro\\", \\"soft\\"]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options","typeRefId":"string","array":true},{"name":"nfs","description":"nfs represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs","typeRefId":"nfsvolumesource-v1-core","array":false},{"name":"nodeAffinity","description":"nodeAffinity defines constraints that limit what nodes this volume can be accessed from. This field influences the scheduling of pods that use this volume.","typeRefId":"volumenodeaffinity-v1-core","array":false},{"name":"persistentVolumeReclaimPolicy","description":"persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming Possible enum values: - `\\"Delete\\"` means the volume will be deleted from Kubernetes on release from its claim. The volume plugin must support Deletion. - `\\"Recycle\\"` means the volume will be recycled back into the pool of unbound persistent volumes on release from its claim. The volume plugin must support Recycling. - `\\"Retain\\"` means the volume will be left in its current phase (Released) for manual reclamation by the administrator. The default policy is Retain.","typeRefId":"string","array":false},{"name":"photonPersistentDisk","description":"photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine. Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.","typeRefId":"photonpersistentdiskvolumesource-v1-core","array":false},{"name":"portworxVolume","description":"portworxVolume represents a portworx volume attached and mounted on kubelets host machine. Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate is on.","typeRefId":"portworxvolumesource-v1-core","array":false},{"name":"quobyte","description":"quobyte represents a Quobyte mount on the host that shares a pod\'s lifetime. Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.","typeRefId":"quobytevolumesource-v1-core","array":false},{"name":"rbd","description":"rbd represents a Rados Block Device mount on the host that shares a pod\'s lifetime. Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported. More info: https://examples.k8s.io/volumes/rbd/README.md","typeRefId":"rbdpersistentvolumesource-v1-core","array":false},{"name":"scaleIO","description":"scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes. Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.","typeRefId":"scaleiopersistentvolumesource-v1-core","array":false},{"name":"storageClassName","description":"storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.","typeRefId":"string","array":false},{"name":"storageos","description":"storageOS represents a StorageOS volume that is attached to the kubelet\'s host machine and mounted into the pod. Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported. More info: https://examples.k8s.io/volumes/storageos/README.md","typeRefId":"storageospersistentvolumesource-v1-core","array":false},{"name":"volumeAttributesClassName","description":"Name of VolumeAttributesClass to which this persistent volume belongs. Empty value is not allowed. When this field is not set, it indicates that this volume does not belong to any VolumeAttributesClass. This field is mutable and can be changed by the CSI driver after a volume has been updated successfully to a new class. For an unbound PersistentVolume, the volumeAttributesClassName will be matched with unbound PersistentVolumeClaims during the binding process.","typeRefId":"string","array":false},{"name":"volumeMode","description":"volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec. Possible enum values: - `\\"Block\\"` means the volume will not be formatted with a filesystem and will remain a raw block device. - `\\"Filesystem\\"` means the volume will be or is formatted with a filesystem.","typeRefId":"string","array":false},{"name":"vsphereVolume","description":"vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine. Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type are redirected to the csi.vsphere.vmware.com CSI driver.","typeRefId":"vspherevirtualdiskvolumesource-v1-core","array":false}],"appears":[{"typeRefId":"persistentvolume-v1-core","text":"PersistentVolume [core/v1]"},{"typeRefId":"volumeattachmentsource-v1-storage-k8s-io","text":"VolumeAttachmentSource [storage/v1]"}]},"persistentvolumestatus-v1-core":{"id":"persistentvolumestatus-v1-core","name":"PersistentVolumeStatus v1 core","primitive":false,"description":"PersistentVolumeStatus v1 core","fields":[{"name":"lastPhaseTransitionTime","description":"lastPhaseTransitionTime is the time the phase transitioned from one to another and automatically resets to current time everytime a volume phase transitions.","typeRefId":"time-v1-meta","array":false},{"name":"message","description":"message is a human-readable message indicating details about why the volume is in this state.","typeRefId":"string","array":false},{"name":"phase","description":"phase indicates if a volume is available, bound to a claim, or released by a claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase Possible enum values: - `\\"Available\\"` used for PersistentVolumes that are not yet bound Available volumes are held by the binder and matched to PersistentVolumeClaims - `\\"Bound\\"` used for PersistentVolumes that are bound - `\\"Failed\\"` used for PersistentVolumes that failed to be correctly recycled or deleted after being released from a claim - `\\"Pending\\"` used for PersistentVolumes that are not available - `\\"Released\\"` used for PersistentVolumes where the bound PersistentVolumeClaim was deleted released volumes must be recycled before becoming available again this phase is used by the persistent volume claim binder to signal to another process to reclaim the resource","typeRefId":"string","array":false},{"name":"reason","description":"reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI.","typeRefId":"string","array":false}],"appears":[{"typeRefId":"persistentvolume-v1-core","text":"PersistentVolume [core/v1]"}]},"resourcequotaspec-v1-core":{"id":"resourcequotaspec-v1-core","name":"ResourceQuotaSpec v1 core","primitive":false,"description":"ResourceQuotaSpec v1 core","fields":[{"name":"hard","description":"hard is the set of desired hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/","typeRefId":"object","array":false},{"name":"scopeSelector","description":"scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota but expressed using ScopeSelectorOperator in combination with possible values. For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.","typeRefId":"scopeselector-v1-core","array":false},{"name":"scopes","description":"A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects.","typeRefId":"string","array":true}],"appears":[{"typeRefId":"resourcequota-v1-core","text":"ResourceQuota [core/v1]"}]},"resourcequotastatus-v1-core":{"id":"resourcequotastatus-v1-core","name":"ResourceQuotaStatus v1 core","primitive":false,"description":"ResourceQuotaStatus v1 core","fields":[{"name":"hard","description":"Hard is the set of enforced hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/","typeRefId":"object","array":false},{"name":"used","description":"Used is the current observed total usage of the resource in the namespace.","typeRefId":"object","array":false}],"appears":[{"typeRefId":"resourcequota-v1-core","text":"ResourceQuota [core/v1]"}]},"horizontalpodautoscalerspec-v1-autoscaling":{"id":"horizontalpodautoscalerspec-v1-autoscaling","name":"HorizontalPodAutoscalerSpec v1 autoscaling","primitive":false,"description":"HorizontalPodAutoscalerSpec v1 autoscaling","fields":[{"name":"maxReplicas","description":"maxReplicas is the upper limit for the number of pods that can be set by the autoscaler; cannot be smaller than MinReplicas.","typeRefId":"integer","array":false},{"name":"minReplicas","description":"minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down. It defaults to 1 pod. minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured. Scaling is active as long as at least one metric value is available.","typeRefId":"integer","array":false},{"name":"scaleTargetRef","description":"reference to scaled resource; horizontal pod autoscaler will learn the current resource consumption and will set the desired number of pods by using its Scale subresource.","typeRefId":"crossversionobjectreference-v1-autoscaling","array":false},{"name":"targetCPUUtilizationPercentage","description":"targetCPUUtilizationPercentage is the target average CPU utilization (represented as a percentage of requested CPU) over all the pods; if not specified the default autoscaling policy will be used.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"horizontalpodautoscaler-v1-autoscaling","text":"HorizontalPodAutoscaler [autoscaling/v1]"}]},"horizontalpodautoscalerstatus-v1-autoscaling":{"id":"horizontalpodautoscalerstatus-v1-autoscaling","name":"HorizontalPodAutoscalerStatus v1 autoscaling","primitive":false,"description":"HorizontalPodAutoscalerStatus v1 autoscaling","fields":[{"name":"currentCPUUtilizationPercentage","description":"currentCPUUtilizationPercentage is the current average CPU utilization over all pods, represented as a percentage of requested CPU, e.g. 70 means that an average pod is using now 70% of its requested CPU.","typeRefId":"integer","array":false},{"name":"currentReplicas","description":"currentReplicas is the current number of replicas of pods managed by this autoscaler.","typeRefId":"integer","array":false},{"name":"desiredReplicas","description":"desiredReplicas is the desired number of replicas of pods managed by this autoscaler.","typeRefId":"integer","array":false},{"name":"lastScaleTime","description":"lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods; used by the autoscaler to control how often the number of pods is changed.","typeRefId":"time-v1-meta","array":false},{"name":"observedGeneration","description":"observedGeneration is the most recent generation observed by this autoscaler.","typeRefId":"integer","array":false}],"appears":[{"typeRefId":"horizontalpodautoscaler-v1-autoscaling","text":"HorizontalPodAutoscaler [autoscaling/v1]"}]},"deploymentstrategy-v1-apps":{"id":"deploymentstrategy-v1-apps","name":"DeploymentStrategy v1 apps","primitive":false,"description":"DeploymentStrategy v1 apps","fields":[{"name":"rollingUpdate","description":"Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.","typeRefId":"rollingupdatedeployment-v1-apps","array":false},{"name":"type","description":"Type of deployment. Can be \\"Recreate\\" or \\"RollingUpdate\\". Default is RollingUpdate. Possible enum values: - `\\"Recreate\\"` Kill all existing pods before creating new ones. - `\\"RollingUpdate\\"` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.","typeRefId":"string","array":false}],"appears":[{"typeRefId":"deploymentspec-v1-apps","text":"DeploymentSpec [apps/v1]"}]},"containerstatus-v1-core":{"id":"containerstatus-v1-core","name":"ContainerStatus v1 core","primitive":false,"description":"ContainerStatus v1 core","fields":[{"name":"allocatedResources","description":"AllocatedResources represents the compute resources allocated for this container by the node. Kubelet sets this value to Container.Resources.Requests upon successful pod admission and after successfully admitting desired pod resize.","typeRefId":"object","array":false},{"name":"allocatedResourcesStatus","description":"AllocatedResourcesStatus represents the status of various resources allocated for this Pod.","typeRefId":"resourcestatus-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"name"}},{"name":"containerID","description":"ContainerID is the ID of the container in the format \'<type>://<container_id>\'. Where type is a container runtime identifier, returned from Version call of CRI API (for example \\"containerd\\").","typeRefId":"string","array":false},{"name":"image","description":"Image is the name of container image that the container is running. The container image may not match the image used in the PodSpec, as it may have been resolved by the runtime. More info: https://kubernetes.io/docs/concepts/containers/images.","typeRefId":"string","array":false},{"name":"imageID","description":"ImageID is the image ID of the container\'s image. The image ID may not match the image ID of the image used in the PodSpec, as it may have been resolved by the runtime.","typeRefId":"string","array":false},{"name":"lastState","description":"LastTerminationState holds the last termination state of the container to help debug container crashes and restarts. This field is not populated if the container is still running and RestartCount is 0.","typeRefId":"containerstate-v1-core","array":false},{"name":"name","description":"Name is a DNS_LABEL representing the unique name of the container. Each container in a pod must have a unique name across all container types. Cannot be updated.","typeRefId":"string","array":false},{"name":"ready","description":"Ready specifies whether the container is currently passing its readiness check. The value will change as readiness probes keep executing. If no readiness probes are specified, this field defaults to true once the container is fully started (see Started field). The value is typically used to determine whether a container is ready to accept traffic.","typeRefId":"boolean","array":false},{"name":"resources","description":"Resources represents the compute resource requests and limits that have been successfully enacted on the running container after it has been started or has been successfully resized.","typeRefId":"resourcerequirements-v1-core","array":false},{"name":"restartCount","description":"RestartCount holds the number of times the container has been restarted. Kubelet makes an effort to always increment the value, but there are cases when the state may be lost due to node restarts and then the value may be reset to 0. The value is never negative.","typeRefId":"integer","array":false},{"name":"started","description":"Started indicates whether the container has finished its postStart lifecycle hook and passed its startup probe. Initialized as false, becomes true after startupProbe is considered successful. Resets to false when the container is restarted, or if kubelet loses state temporarily. In both cases, startup probes will run again. Is always true when no startupProbe is defined and container is running and has passed the postStart lifecycle hook. The null value must be treated the same as false.","typeRefId":"boolean","array":false},{"name":"state","description":"State holds details about the container\'s current condition.","typeRefId":"containerstate-v1-core","array":false},{"name":"stopSignal","description":"StopSignal reports the effective stop signal for this container Possible enum values: - `\\"SIGABRT\\"` - `\\"SIGALRM\\"` - `\\"SIGBUS\\"` - `\\"SIGCHLD\\"` - `\\"SIGCLD\\"` - `\\"SIGCONT\\"` - `\\"SIGFPE\\"` - `\\"SIGHUP\\"` - `\\"SIGILL\\"` - `\\"SIGINT\\"` - `\\"SIGIO\\"` - `\\"SIGIOT\\"` - `\\"SIGKILL\\"` - `\\"SIGPIPE\\"` - `\\"SIGPOLL\\"` - `\\"SIGPROF\\"` - `\\"SIGPWR\\"` - `\\"SIGQUIT\\"` - `\\"SIGRTMAX\\"` - `\\"SIGRTMAX-1\\"` - `\\"SIGRTMAX-10\\"` - `\\"SIGRTMAX-11\\"` - `\\"SIGRTMAX-12\\"` - `\\"SIGRTMAX-13\\"` - `\\"SIGRTMAX-14\\"` - `\\"SIGRTMAX-2\\"` - `\\"SIGRTMAX-3\\"` - `\\"SIGRTMAX-4\\"` - `\\"SIGRTMAX-5\\"` - `\\"SIGRTMAX-6\\"` - `\\"SIGRTMAX-7\\"` - `\\"SIGRTMAX-8\\"` - `\\"SIGRTMAX-9\\"` - `\\"SIGRTMIN\\"` - `\\"SIGRTMIN+1\\"` - `\\"SIGRTMIN+10\\"` - `\\"SIGRTMIN+11\\"` - `\\"SIGRTMIN+12\\"` - `\\"SIGRTMIN+13\\"` - `\\"SIGRTMIN+14\\"` - `\\"SIGRTMIN+15\\"` - `\\"SIGRTMIN+2\\"` - `\\"SIGRTMIN+3\\"` - `\\"SIGRTMIN+4\\"` - `\\"SIGRTMIN+5\\"` - `\\"SIGRTMIN+6\\"` - `\\"SIGRTMIN+7\\"` - `\\"SIGRTMIN+8\\"` - `\\"SIGRTMIN+9\\"` - `\\"SIGSEGV\\"` - `\\"SIGSTKFLT\\"` - `\\"SIGSTOP\\"` - `\\"SIGSYS\\"` - `\\"SIGTERM\\"` - `\\"SIGTRAP\\"` - `\\"SIGTSTP\\"` - `\\"SIGTTIN\\"` - `\\"SIGTTOU\\"` - `\\"SIGURG\\"` - `\\"SIGUSR1\\"` - `\\"SIGUSR2\\"` - `\\"SIGVTALRM\\"` - `\\"SIGWINCH\\"` - `\\"SIGXCPU\\"` - `\\"SIGXFSZ\\"`","typeRefId":"string","array":false},{"name":"user","description":"User represents user identity information initially attached to the first process of the container","typeRefId":"containeruser-v1-core","array":false},{"name":"volumeMounts","description":"Status of volume mounts.","typeRefId":"volumemountstatus-v1-core","array":true,"patch":{"strategy":["merge"],"mergeKey":"mountPath"}}],"appears":[{"typeRefId":"podstatus-v1-core","text":"PodStatus [core/v1]"}]},"rollingupdatedeployment-v1-apps":{"id":"rollingupdatedeployment-v1-apps","name":"RollingUpdateDeployment v1 apps","primitive":false,"description":"RollingUpdateDeployment v1 apps","fields":[{"name":"maxSurge","description":"The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.","array":false},{"name":"maxUnavailable","description":"The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.","array":false}],"appears":[{"typeRefId":"deploymentstrategy-v1-apps","text":"DeploymentStrategy [apps/v1]"}]}}}')}});
//# sourceMappingURL=app.021cd556.js.map